{"ast":null,"code":"import _classCallCheck from \"/Users/mlabouardy/go/src/github.com/mlabouardy/komiser/dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mlabouardy/go/src/github.com/mlabouardy/komiser/dashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _toConsumableArray from \"/Users/mlabouardy/go/src/github.com/mlabouardy/komiser/dashboard/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _toArray from \"/Users/mlabouardy/go/src/github.com/mlabouardy/komiser/dashboard/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport { animate, keyframes, state, style, transition, trigger } from '@angular/animations';\nimport { Component, Input, ViewChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/* eslint-disable no-restricted-properties */\n\n/**\n * normalize\n * This lets us translate a value from one scale to another.\n *\n * @param {?} value - Our initial value to translate\n * @param {?} min - the current minimum value possible\n * @param {?} max - the current maximum value possible\n * @param {?=} scaleMin - the min value of the scale we're translating to\n * @param {?=} scaleMax - the max value of the scale we're translating to\n *\n * @return {?} the value on its new scale\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nvar _c0 = [\"pathEl\"];\n\nfunction TrendComponent__svg_svg_0__svg_defs_1__svg_stop_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"stop\");\n  }\n\n  if (rf & 2) {\n    var g_r4 = ctx.$implicit;\n    ɵngcc0.ɵɵattribute(\"key\", g_r4.idx)(\"offset\", g_r4.offset)(\"stop-color\", g_r4.stopColor);\n  }\n}\n\nfunction TrendComponent__svg_svg_0__svg_defs_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"defs\");\n    ɵngcc0.ɵɵelementStart(1, \"linearGradient\", 3);\n    ɵngcc0.ɵɵtemplate(2, TrendComponent__svg_svg_0__svg_defs_1__svg_stop_2_Template, 1, 3, \"stop\", 4);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"id\", ctx_r1.gradientId);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r1.gradientTrimmed);\n  }\n}\n\nvar _c1 = function _c1(a0, a1, a2) {\n  return {\n    autoDrawDuration: a0,\n    autoDrawEasing: a1,\n    lineLength: a2\n  };\n};\n\nvar _c2 = function _c2(a0, a1) {\n  return {\n    value: a0,\n    params: a1\n  };\n};\n\nfunction TrendComponent__svg_svg_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"svg\");\n    ɵngcc0.ɵɵtemplate(1, TrendComponent__svg_svg_0__svg_defs_1_Template, 3, 2, \"defs\", 0);\n    ɵngcc0.ɵɵelement(2, \"path\", 1, 2);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵattribute(\"width\", ctx_r0.svgWidth)(\"height\", ctx_r0.svgHeight)(\"stroke\", ctx_r0.stroke)(\"stroke-width\", ctx_r0.strokeWidth)(\"stroke-linecap\", ctx_r0.strokeLinecap)(\"viewBox\", ctx_r0.viewBox)(\"preserveAspectRatio\", ctx_r0.preserveAspectRatio);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.gradient && ctx_r0.gradient.length);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"@pathAnimaiton\", ɵngcc0.ɵɵpureFunction2(15, _c2, ctx_r0.animationState, ɵngcc0.ɵɵpureFunction3(11, _c1, ctx_r0.autoDrawDuration, ctx_r0.autoDrawEasing, ctx_r0.lineLength)));\n    ɵngcc0.ɵɵattribute(\"stroke\", ctx_r0.pathStroke)(\"d\", ctx_r0.d);\n  }\n}\n\nfunction normalize(value, min, max) {\n  var scaleMin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var scaleMax = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n\n  // If the `min` and `max` are the same value, it means our dataset is flat.\n  // For now, let's assume that flat data should be aligned to the bottom.\n  if (min === max) {\n    return scaleMin;\n  }\n\n  return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);\n}\n/**\n * moveTo\n * the coordinate that lies at a midpoint between 2 lines, based on the radius\n *\n * @param {?} to - Our initial point\n * @param {?} from - Our final point\n * @param {?} radius - The distance away from the final point\n *\n * @return {?} an object holding the x/y coordinates of the midpoint.\n */\n\n\nfunction moveTo(to, from, radius) {\n  /** @type {?} */\n  var length = Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));\n  /** @type {?} */\n\n  var unitVector = {\n    x: (to.x - from.x) / length,\n    y: (to.y - from.y) / length\n  };\n  return {\n    x: from.x + unitVector.x * radius,\n    y: from.y + unitVector.y * radius\n  };\n}\n/**\n * getDistanceBetween\n * Simple formula derived from pythagoras to calculate the distance between\n * 2 points on a plane.\n *\n * \\@param p1 - Our initial point\n * \\@param p1.x - The x value of our initial point\n * \\@param p1.y - The y value of our initial point\n * \\@param p2 - Our final point\n * \\@param p2.x - The x value of our final point\n * \\@param p2.y - The y value of our final point\n *\n * \\@return the distance between the points.\n * @type {?}\n */\n\n\nvar getDistanceBetween = function getDistanceBetween(p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n};\n/**\n * checkForCollinearPoints\n * Figure out if the midpoint fits perfectly on a line between the two others.\n *\n * \\@param p1 - Our initial point\n * \\@param p1.x - The x value of our initial point\n * \\@param p1.y - The y value of our initial point\n * \\@param p2 - Our mid-point\n * \\@param p2.x - The x value of our mid-point\n * \\@param p2.y - The y value of our mid-point\n * \\@param p3 - Our final point\n * \\@param p3.x - The x value of our final point\n * \\@param p3.y - The y value of our final point\n * \\@return whether or not p2 sits on the line between p1 and p3.\n * @type {?}\n */\n\n\nvar checkForCollinearPoints = function checkForCollinearPoints(p1, p2, p3) {\n  return (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar buildLinearPath = function buildLinearPath(data) {\n  return data.reduce(function (path, point, index) {\n    // The very first instruction needs to be a \"move\".\n    // The rest will be a \"line\".\n\n    /** @type {?} */\n    var isFirstInstruction = index === 0;\n    /** @type {?} */\n\n    var instruction = isFirstInstruction ? 'M' : 'L';\n    return \"\".concat(path).concat(instruction, \" \").concat(point.x, \",\").concat(point.y, \"\\n\");\n  }, '');\n};\n/**\n * @param {?} data\n * @param {?} radius\n * @return {?}\n */\n\n\nfunction buildSmoothPath(data, radius) {\n  var _data = _toArray(data),\n      firstPoint = _data[0],\n      otherPoints = _data.slice(1);\n\n  return otherPoints.reduce(function (path, point, index) {\n    /** @type {?} */\n    var next = otherPoints[index + 1];\n    /** @type {?} */\n\n    var prev = otherPoints[index - 1] || firstPoint;\n    /** @type {?} */\n\n    var isCollinear = next && checkForCollinearPoints(prev, point, next);\n\n    if (!next || isCollinear) {\n      // The very last line in the sequence can just be a regular line.\n      return \"\".concat(path, \"\\nL \").concat(point.x, \",\").concat(point.y);\n    }\n    /** @type {?} */\n\n\n    var distanceFromPrev = getDistanceBetween(prev, point);\n    /** @type {?} */\n\n    var distanceFromNext = getDistanceBetween(next, point);\n    /** @type {?} */\n\n    var threshold = Math.min(distanceFromPrev, distanceFromNext);\n    /** @type {?} */\n\n    var isTooCloseForRadius = threshold / 2 < radius;\n    /** @type {?} */\n\n    var radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;\n    /** @type {?} */\n\n    var before = moveTo(prev, point, radiusForPoint);\n    /** @type {?} */\n\n    var after = moveTo(next, point, radiusForPoint);\n    return [path, \"L \".concat(before.x, \",\").concat(before.y), \"S \".concat(point.x, \",\").concat(point.y, \" \").concat(after.x, \",\").concat(after.y)].join('\\n');\n  }, \"M \".concat(firstPoint.x, \",\").concat(firstPoint.y));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar generateId = function generateId() {\n  return Math.round(Math.random() * Math.pow(10, 16));\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @param {?} minX\n * @param {?} maxX\n * @param {?} minY\n * @param {?} maxY\n * @return {?}\n */\n\n\nfunction normalizeDataset(data, minX, maxX, minY, maxY) {\n  // For the X axis, we want to normalize it based on its index in the array.\n  // For the Y axis, we want to normalize it based on the element's value.\n  //\n  // X axis is easy: just evenly-space each item in the array.\n  // For the Y axis, we first need to find the min and max of our array,\n  // and then normalize those values between 0 and 1.\n\n  /** @type {?} */\n  var boundariesX = {\n    min: 0,\n    max: data.length - 1\n  };\n  /** @type {?} */\n\n  var boundariesY = {\n    min: Math.min.apply(Math, _toConsumableArray(data)),\n    max: Math.max.apply(Math, _toConsumableArray(data))\n  };\n  /** @type {?} */\n\n  var normalizedData = data.map(function (point, index) {\n    return {\n      x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),\n      y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY)\n    };\n  }); // According to the SVG spec, paths with a height/width of `0` can't have\n  // linear gradients applied. This means that our lines are invisible when\n  // the dataset is flat (eg. [0, 0, 0, 0]).\n  //\n  // The hacky solution is to apply a very slight offset to the first point of\n  // the dataset. As ugly as it is, it's the best solution we can find (there\n  // are ways within the SVG spec of changing it, but not without causing\n  // breaking changes).\n\n  if (boundariesY.min === boundariesY.max) {\n    normalizedData[0].y += 0.0001;\n  }\n\n  return normalizedData;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nvar TrendComponent = /*#__PURE__*/(function () {\n  var TrendComponent = /*#__PURE__*/function () {\n    function TrendComponent() {\n      _classCallCheck(this, TrendComponent);\n\n      this.autoDraw = false;\n      this.autoDrawDuration = 2000;\n      this.autoDrawEasing = 'ease';\n      this.padding = 8;\n      this.radius = 10;\n      this.stroke = 'black';\n      this.strokeLinecap = '';\n      this.strokeWidth = 1;\n      this.gradient = [];\n      this.svgHeight = '25%';\n      this.svgWidth = '100%';\n      this.animationState = '';\n      this.id = generateId();\n      this.gradientId = \"ngx-trend-vertical-gradient-\".concat(this.id);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(TrendComponent, [{\n      key: \"ngOnChanges\",\n      value: function ngOnChanges() {\n        var _this = this;\n\n        // We need at least 2 points to draw a graph.\n        if (!this.data || this.data.length < 2) {\n          return;\n        } // `data` can either be an array of numbers:\n        // [1, 2, 3]\n        // or, an array of objects containing a value:\n        // [{ value: 1 }, { value: 2 }, { value: 3 }]\n        //\n        // For now, we're just going to convert the second form to the first.\n        // Later on, if/when we support tooltips, we may adjust.\n\n        /** @type {?} */\n\n\n        var plainValues = this.data.map(function (point) {\n          if (typeof point === 'number') {\n            return point;\n          }\n\n          return point.value;\n        }); // Our viewbox needs to be in absolute units, so we'll default to 300x75\n        // Our SVG can be a %, though; this is what makes it scalable.\n        // By defaulting to percentages, the SVG will grow to fill its parent\n        // container, preserving a 1/4 aspect ratio.\n\n        /** @type {?} */\n\n        var viewBoxWidth = this.width || 300;\n        /** @type {?} */\n\n        var viewBoxHeight = this.height || 75;\n        this.svgWidth = this.width || '100%';\n        this.svgHeight = this.height || '25%';\n        this.viewBox = \"0 0 \".concat(viewBoxWidth, \" \").concat(viewBoxHeight);\n        /** @type {?} */\n\n        var root = location.href.split(location.hash || '#')[0];\n        this.pathStroke = this.gradient && this.gradient.length ? \"url('\".concat(root, \"#\").concat(this.gradientId, \"')\") : undefined;\n        this.gradientTrimmed = this.gradient.slice().reverse().map(function (val, idx) {\n          return {\n            idx: idx,\n            stopColor: val,\n            offset: normalize(idx, 0, _this.gradient.length - 1 || 1)\n          };\n        });\n        /** @type {?} */\n\n        var normalizedValues = normalizeDataset(plainValues, this.padding, viewBoxWidth - this.padding, // NOTE: Because SVGs are indexed from the top left, but most data is\n        // indexed from the bottom left, we're inverting the Y min/max.\n        viewBoxHeight - this.padding, this.padding);\n\n        if (this.autoDraw && this.animationState !== 'active') {\n          this.animationState = 'inactive';\n          setTimeout(function () {\n            _this.lineLength = _this.pathEl.nativeElement.getTotalLength();\n            _this.animationState = 'active';\n          });\n        }\n\n        this.d = this.smooth ? buildSmoothPath(normalizedValues, this.radius) : buildLinearPath(normalizedValues);\n      }\n    }]);\n\n    return TrendComponent;\n  }();\n\n  TrendComponent.ɵfac = function TrendComponent_Factory(t) {\n    return new (t || TrendComponent)();\n  };\n\n  TrendComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TrendComponent,\n    selectors: [[\"ngx-trend\"]],\n    viewQuery: function TrendComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pathEl = _t.first);\n      }\n    },\n    inputs: {\n      autoDraw: \"autoDraw\",\n      autoDrawDuration: \"autoDrawDuration\",\n      autoDrawEasing: \"autoDrawEasing\",\n      padding: \"padding\",\n      radius: \"radius\",\n      stroke: \"stroke\",\n      strokeLinecap: \"strokeLinecap\",\n      strokeWidth: \"strokeWidth\",\n      gradient: \"gradient\",\n      svgHeight: \"svgHeight\",\n      svgWidth: \"svgWidth\",\n      data: \"data\",\n      smooth: \"smooth\",\n      width: \"width\",\n      height: \"height\",\n      preserveAspectRatio: \"preserveAspectRatio\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [\"fill\", \"none\"], [\"pathEl\", \"\"], [\"x1\", \"0%\", \"y1\", \"0%\", \"x2\", \"0%\", \"y2\", \"100%\"], [4, \"ngFor\", \"ngForOf\"]],\n    template: function TrendComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TrendComponent__svg_svg_0_Template, 4, 18, \"svg\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.data && ctx.data.length >= 2);\n      }\n    },\n    directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('pathAnimaiton', [state('inactive', style({\n        display: 'none'\n      })), transition('* => active', [style({\n        display: 'initial'\n      }), // We do the animation using the dash array/offset trick\n      // https://css-tricks.com/svg-line-animation-works/\n      animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', keyframes([style({\n        'stroke-dasharray': '{{ lineLength }}px',\n        'stroke-dashoffset': '{{ lineLength }}px'\n      }), style({\n        'stroke-dasharray': '{{ lineLength }}px',\n        'stroke-dashoffset': 0\n      })])), // One unfortunate side-effect of the auto-draw is that the line is\n      // actually 1 big dash, the same length as the line itself. If the\n      // line length changes (eg. radius change, new data), that dash won't\n      // be the same length anymore. We can fix that by removing those\n      // properties once the auto-draw is completed.\n      style({\n        'stroke-dashoffset': '',\n        'stroke-dasharray': ''\n      })])])]\n    }\n  });\n  /** @nocollapse */\n\n  return TrendComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nvar TrendModule = /*#__PURE__*/(function () {\n  var TrendModule = /*#__PURE__*/_createClass(function TrendModule() {\n    _classCallCheck(this, TrendModule);\n  });\n\n  TrendModule.ɵfac = function TrendModule_Factory(t) {\n    return new (t || TrendModule)();\n  };\n\n  TrendModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TrendModule\n  });\n  TrendModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return TrendModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TrendModule, {\n    declarations: function declarations() {\n      return [TrendComponent];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [TrendComponent];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { TrendComponent, TrendModule }; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXRyZW5kLmpzIiwic291cmNlcyI6WyJuZ3gtdHJlbmQvaGVscGVycy9tYXRoLmhlbHBlcnMudHMiLCJuZ3gtdHJlbmQvaGVscGVycy9ET00uaGVscGVycy50cyIsIm5neC10cmVuZC9oZWxwZXJzL21pc2MuaGVscGVycy50cyIsIm5neC10cmVuZC90cmVuZC90cmVuZC5oZWxwZXJzLnRzIiwibmd4LXRyZW5kL3RyZW5kL3RyZW5kLmNvbXBvbmVudC50cyIsIm5neC10cmVuZC90cmVuZC90cmVuZC5tb2R1bGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYUEsU0FBZ0IsU0FBUyxDQUN2QixLQUFhLEVBQ2IsR0FBVyxFQUNYLEdBQVcsRUFDWCxRQUFRLEdBQUcsQ0FBQyxFQUNaLFFBQVEsR0FBRyxDQUFDO0FBQ1o7QUFFRjtBQUNFLElBQUEsSUFBSSxHQUFHLEtBQUssR0FBRyxFQUFFO0FBQ25CLFFBQUksT0FBTyxRQUFRLENBQUM7QUFDcEIsS0FBRztBQUNILElBQ0UsT0FBTyxRQUFRLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxLQUFLLFFBQVEsR0FBRyxRQUFRLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDeEUsQ0FBQztBQUNEO0FBQ0c7QUFBVTtBQU1jO0FBQUc7QUFBcUM7QUFFN0M7QUFFckI7QUFBRztBQUNvQjtBQU94QixTQUFnQixNQUFNLENBQUMsRUFBUyxFQUFFLElBQVcsRUFBRSxNQUFjO0FBQUk7QUFDbkQsVUFBTixNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENB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QUFDO0FBQUk7QUFFSztBQUFrRTtBQUFJO0FBQUM7QUFBSTtBQUFrQztBQUFrRTtBQUFJO0FBQUM7O0FMQ0EsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUlBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBb0JBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQWVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBaUJBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFDekZBLEFBT0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUdBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUNoREEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQ0FBLEFBRUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFRQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFVQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFDcENBLEFBd0ZBLEFBQUEsQUEyQkEsQUF2QkEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBR0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFRQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBR0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUNBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFTQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQU1BLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUdBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUNBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBN0pBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBK0JBLEFBQ0EsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBR0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBTUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQ0EsQUFHQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUMxR0EsQUFVQSxBQUFBLEFBTEEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXByb3BlcnRpZXMgKi9cblxuLyoqIG5vcm1hbGl6ZVxuICogVGhpcyBsZXRzIHVzIHRyYW5zbGF0ZSBhIHZhbHVlIGZyb20gb25lIHNjYWxlIHRvIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gT3VyIGluaXRpYWwgdmFsdWUgdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0gbWluIC0gdGhlIGN1cnJlbnQgbWluaW11bSB2YWx1ZSBwb3NzaWJsZVxuICogQHBhcmFtIG1heCAtIHRoZSBjdXJyZW50IG1heGltdW0gdmFsdWUgcG9zc2libGVcbiAqIEBwYXJhbSBzY2FsZU1pbiAtIHRoZSBtaW4gdmFsdWUgb2YgdGhlIHNjYWxlIHdlJ3JlIHRyYW5zbGF0aW5nIHRvXG4gKiBAcGFyYW0gc2NhbGVNYXggLSB0aGUgbWF4IHZhbHVlIG9mIHRoZSBzY2FsZSB3ZSdyZSB0cmFuc2xhdGluZyB0b1xuICpcbiAqIEByZXR1cm5zIHRoZSB2YWx1ZSBvbiBpdHMgbmV3IHNjYWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoXG4gIHZhbHVlOiBudW1iZXIsXG4gIG1pbjogbnVtYmVyLFxuICBtYXg6IG51bWJlcixcbiAgc2NhbGVNaW4gPSAwLFxuICBzY2FsZU1heCA9IDEsXG4pIHtcbiAgLy8gSWYgdGhlIGBtaW5gIGFuZCBgbWF4YCBhcmUgdGhlIHNhbWUgdmFsdWUsIGl0IG1lYW5zIG91ciBkYXRhc2V0IGlzIGZsYXQuXG4gIC8vIEZvciBub3csIGxldCdzIGFzc3VtZSB0aGF0IGZsYXQgZGF0YSBzaG91bGQgYmUgYWxpZ25lZCB0byB0aGUgYm90dG9tLlxuICBpZiAobWluID09PSBtYXgpIHtcbiAgICByZXR1cm4gc2NhbGVNaW47XG4gIH1cblxuICByZXR1cm4gc2NhbGVNaW4gKyAodmFsdWUgLSBtaW4pICogKHNjYWxlTWF4IC0gc2NhbGVNaW4pIC8gKG1heCAtIG1pbik7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9pbnQge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn1cblxuLyoqIG1vdmVUb1xuICogdGhlIGNvb3JkaW5hdGUgdGhhdCBsaWVzIGF0IGEgbWlkcG9pbnQgYmV0d2VlbiAyIGxpbmVzLCBiYXNlZCBvbiB0aGUgcmFkaXVzXG4gKlxuICogQHBhcmFtIHRvIC0gT3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSB0by54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSB0by55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBmcm9tIC0gT3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gZnJvbS54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gZnJvbS55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcmFkaXVzIC0gVGhlIGRpc3RhbmNlIGF3YXkgZnJvbSB0aGUgZmluYWwgcG9pbnRcbiAqXG4gKiBAcmV0dXJucyBhbiBvYmplY3QgaG9sZGluZyB0aGUgeC95IGNvb3JkaW5hdGVzIG9mIHRoZSBtaWRwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdmVUbyh0bzogUG9pbnQsIGZyb206IFBvaW50LCByYWRpdXM6IG51bWJlcik6IFBvaW50IHtcbiAgY29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KCh0by54IC0gZnJvbS54KSAqICh0by54IC0gZnJvbS54KSArICh0by55IC0gZnJvbS55KSAqICh0by55IC0gZnJvbS55KSk7XG4gIGNvbnN0IHVuaXRWZWN0b3IgPSB7IHg6ICh0by54IC0gZnJvbS54KSAvIGxlbmd0aCwgeTogKHRvLnkgLSBmcm9tLnkpIC8gbGVuZ3RoIH07XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBmcm9tLnggKyB1bml0VmVjdG9yLnggKiByYWRpdXMsXG4gICAgeTogZnJvbS55ICsgdW5pdFZlY3Rvci55ICogcmFkaXVzLFxuICB9O1xufVxuXG4vKiogZ2V0RGlzdGFuY2VCZXR3ZWVuXG4gKiBTaW1wbGUgZm9ybXVsYSBkZXJpdmVkIGZyb20gcHl0aGFnb3JhcyB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW5cbiAqIDIgcG9pbnRzIG9uIGEgcGxhbmUuXG4gKlxuICogQHBhcmFtIHAxIC0gT3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMS54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMS55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMiAtIE91ciBmaW5hbCBwb2ludFxuICogQHBhcmFtIHAyLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBwMi55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKlxuICogQHJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldERpc3RhbmNlQmV0d2VlbiA9IChwMTogUG9pbnQsIHAyOiBQb2ludCkgPT5cbiAgTWF0aC5zcXJ0KE1hdGgucG93KHAyLnggLSBwMS54LCAyKSArIE1hdGgucG93KHAyLnkgLSBwMS55LCAyKSk7XG5cbi8qKiBjaGVja0ZvckNvbGxpbmVhclBvaW50c1xuICogRmlndXJlIG91dCBpZiB0aGUgbWlkcG9pbnQgZml0cyBwZXJmZWN0bHkgb24gYSBsaW5lIGJldHdlZW4gdGhlIHR3byBvdGhlcnMuXG4gKlxuICogQHBhcmFtIHAxIC0gT3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMS54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMS55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMiAtIE91ciBtaWQtcG9pbnRcbiAqIEBwYXJhbSBwMi54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIG1pZC1wb2ludFxuICogQHBhcmFtIHAyLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgbWlkLXBvaW50XG4gKiBAcGFyYW0gcDMgLSBPdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBwMy54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcDMueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBmaW5hbCBwb2ludFxuXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBwMiBzaXRzIG9uIHRoZSBsaW5lIGJldHdlZW4gcDEgYW5kIHAzLlxuICovXG5leHBvcnQgY29uc3QgY2hlY2tGb3JDb2xsaW5lYXJQb2ludHMgPSAocDE6IFBvaW50LCBwMjogUG9pbnQsIHAzOiBQb2ludCkgPT5cbiAgKHAxLnkgLSBwMi55KSAqIChwMS54IC0gcDMueCkgPT09IChwMS55IC0gcDMueSkgKiAocDEueCAtIHAyLngpO1xuIiwiaW1wb3J0IHtcbiAgY2hlY2tGb3JDb2xsaW5lYXJQb2ludHMsXG4gIGdldERpc3RhbmNlQmV0d2VlbixcbiAgbW92ZVRvLFxuICBQb2ludCxcbn0gZnJvbSAnLi9tYXRoLmhlbHBlcnMnO1xuXG5leHBvcnQgY29uc3QgYnVpbGRMaW5lYXJQYXRoID0gKGRhdGE6IFBvaW50W10pID0+XG4gIGRhdGEucmVkdWNlKChwYXRoLCBwb2ludCwgaW5kZXgpID0+IHtcbiAgICAvLyBUaGUgdmVyeSBmaXJzdCBpbnN0cnVjdGlvbiBuZWVkcyB0byBiZSBhIFwibW92ZVwiLlxuICAgIC8vIFRoZSByZXN0IHdpbGwgYmUgYSBcImxpbmVcIi5cbiAgICBjb25zdCBpc0ZpcnN0SW5zdHJ1Y3Rpb24gPSBpbmRleCA9PT0gMDtcbiAgICBjb25zdCBpbnN0cnVjdGlvbiA9IGlzRmlyc3RJbnN0cnVjdGlvbiA/ICdNJyA6ICdMJztcblxuICAgIHJldHVybiBgJHtwYXRofSR7aW5zdHJ1Y3Rpb259ICR7cG9pbnQueH0sJHtwb2ludC55fVxcbmA7XG4gIH0sICcnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU21vb3RoUGF0aChkYXRhOiBQb2ludFtdLCByYWRpdXM6IG51bWJlcikge1xuICBjb25zdCBbZmlyc3RQb2ludCwgLi4ub3RoZXJQb2ludHNdID0gZGF0YTtcblxuICByZXR1cm4gb3RoZXJQb2ludHMucmVkdWNlKChwYXRoLCBwb2ludCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBuZXh0ID0gb3RoZXJQb2ludHNbaW5kZXggKyAxXTtcbiAgICBjb25zdCBwcmV2ID0gb3RoZXJQb2ludHNbaW5kZXggLSAxXSB8fCBmaXJzdFBvaW50O1xuXG4gICAgY29uc3QgaXNDb2xsaW5lYXIgPSBuZXh0ICYmIGNoZWNrRm9yQ29sbGluZWFyUG9pbnRzKHByZXYsIHBvaW50LCBuZXh0KTtcblxuICAgIGlmICghbmV4dCB8fCBpc0NvbGxpbmVhcikge1xuICAgICAgLy8gVGhlIHZlcnkgbGFzdCBsaW5lIGluIHRoZSBzZXF1ZW5jZSBjYW4ganVzdCBiZSBhIHJlZ3VsYXIgbGluZS5cbiAgICAgIHJldHVybiBgJHtwYXRofVxcbkwgJHtwb2ludC54fSwke3BvaW50Lnl9YDtcbiAgICB9XG5cbiAgICBjb25zdCBkaXN0YW5jZUZyb21QcmV2ID0gZ2V0RGlzdGFuY2VCZXR3ZWVuKHByZXYsIHBvaW50KTtcbiAgICBjb25zdCBkaXN0YW5jZUZyb21OZXh0ID0gZ2V0RGlzdGFuY2VCZXR3ZWVuKG5leHQsIHBvaW50KTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBNYXRoLm1pbihkaXN0YW5jZUZyb21QcmV2LCBkaXN0YW5jZUZyb21OZXh0KTtcblxuICAgIGNvbnN0IGlzVG9vQ2xvc2VGb3JSYWRpdXMgPSB0aHJlc2hvbGQgLyAyIDwgcmFkaXVzO1xuXG4gICAgY29uc3QgcmFkaXVzRm9yUG9pbnQgPSBpc1Rvb0Nsb3NlRm9yUmFkaXVzID8gdGhyZXNob2xkIC8gMiA6IHJhZGl1cztcblxuICAgIGNvbnN0IGJlZm9yZSA9IG1vdmVUbyhwcmV2LCBwb2ludCwgcmFkaXVzRm9yUG9pbnQpO1xuICAgIGNvbnN0IGFmdGVyID0gbW92ZVRvKG5leHQsIHBvaW50LCByYWRpdXNGb3JQb2ludCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgcGF0aCxcbiAgICAgIGBMICR7YmVmb3JlLnh9LCR7YmVmb3JlLnl9YCxcbiAgICAgIGBTICR7cG9pbnQueH0sJHtwb2ludC55fSAke2FmdGVyLnh9LCR7YWZ0ZXIueX1gLFxuICAgIF0uam9pbignXFxuJyk7XG4gIH0sIGBNICR7Zmlyc3RQb2ludC54fSwke2ZpcnN0UG9pbnQueX1gKTtcbn1cbiIsImV4cG9ydCBjb25zdCBnZW5lcmF0ZUlkID0gKCkgPT4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMTAsIDE2KSk7XG4iLCJpbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9oZWxwZXJzL21hdGguaGVscGVycyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVEYXRhc2V0KFxuICBkYXRhOiBudW1iZXJbXSxcbiAgbWluWDogbnVtYmVyLFxuICBtYXhYOiBudW1iZXIsXG4gIG1pblk6IG51bWJlcixcbiAgbWF4WTogbnVtYmVyLFxuKSB7XG4gIC8vIEZvciB0aGUgWCBheGlzLCB3ZSB3YW50IHRvIG5vcm1hbGl6ZSBpdCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gdGhlIGFycmF5LlxuICAvLyBGb3IgdGhlIFkgYXhpcywgd2Ugd2FudCB0byBub3JtYWxpemUgaXQgYmFzZWQgb24gdGhlIGVsZW1lbnQncyB2YWx1ZS5cbiAgLy9cbiAgLy8gWCBheGlzIGlzIGVhc3k6IGp1c3QgZXZlbmx5LXNwYWNlIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuXG4gIC8vIEZvciB0aGUgWSBheGlzLCB3ZSBmaXJzdCBuZWVkIHRvIGZpbmQgdGhlIG1pbiBhbmQgbWF4IG9mIG91ciBhcnJheSxcbiAgLy8gYW5kIHRoZW4gbm9ybWFsaXplIHRob3NlIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEuXG4gIGNvbnN0IGJvdW5kYXJpZXNYID0geyBtaW46IDAsIG1heDogZGF0YS5sZW5ndGggLSAxIH07XG4gIGNvbnN0IGJvdW5kYXJpZXNZID0geyBtaW46IE1hdGgubWluKC4uLmRhdGEpLCBtYXg6IE1hdGgubWF4KC4uLmRhdGEpIH07XG5cbiAgY29uc3Qgbm9ybWFsaXplZERhdGEgPSBkYXRhLm1hcCgocG9pbnQsIGluZGV4KSA9PiAoe1xuICAgIHg6IG5vcm1hbGl6ZShpbmRleCwgYm91bmRhcmllc1gubWluLCBib3VuZGFyaWVzWC5tYXgsIG1pblgsIG1heFgpLFxuICAgIHk6IG5vcm1hbGl6ZShwb2ludCwgYm91bmRhcmllc1kubWluLCBib3VuZGFyaWVzWS5tYXgsIG1pblksIG1heFkpLFxuICB9KSk7XG5cbiAgLy8gQWNjb3JkaW5nIHRvIHRoZSBTVkcgc3BlYywgcGF0aHMgd2l0aCBhIGhlaWdodC93aWR0aCBvZiBgMGAgY2FuJ3QgaGF2ZVxuICAvLyBsaW5lYXIgZ3JhZGllbnRzIGFwcGxpZWQuIFRoaXMgbWVhbnMgdGhhdCBvdXIgbGluZXMgYXJlIGludmlzaWJsZSB3aGVuXG4gIC8vIHRoZSBkYXRhc2V0IGlzIGZsYXQgKGVnLiBbMCwgMCwgMCwgMF0pLlxuICAvL1xuICAvLyBUaGUgaGFja3kgc29sdXRpb24gaXMgdG8gYXBwbHkgYSB2ZXJ5IHNsaWdodCBvZmZzZXQgdG8gdGhlIGZpcnN0IHBvaW50IG9mXG4gIC8vIHRoZSBkYXRhc2V0LiBBcyB1Z2x5IGFzIGl0IGlzLCBpdCdzIHRoZSBiZXN0IHNvbHV0aW9uIHdlIGNhbiBmaW5kICh0aGVyZVxuICAvLyBhcmUgd2F5cyB3aXRoaW4gdGhlIFNWRyBzcGVjIG9mIGNoYW5naW5nIGl0LCBidXQgbm90IHdpdGhvdXQgY2F1c2luZ1xuICAvLyBicmVha2luZyBjaGFuZ2VzKS5cbiAgaWYgKGJvdW5kYXJpZXNZLm1pbiA9PT0gYm91bmRhcmllc1kubWF4KSB7XG4gICAgbm9ybWFsaXplZERhdGFbMF0ueSArPSAwLjAwMDE7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZERhdGE7XG59XG4iLCJpbXBvcnQge1xuICBhbmltYXRlLFxuICBrZXlmcmFtZXMsXG4gIHN0YXRlLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvbixcbiAgdHJpZ2dlcixcbn0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGJ1aWxkTGluZWFyUGF0aCwgYnVpbGRTbW9vdGhQYXRoIH0gZnJvbSAnLi4vaGVscGVycy9ET00uaGVscGVycyc7XG5pbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9oZWxwZXJzL21hdGguaGVscGVycyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vaGVscGVycy9taXNjLmhlbHBlcnMnO1xuaW1wb3J0IHsgbm9ybWFsaXplRGF0YXNldCB9IGZyb20gJy4vdHJlbmQuaGVscGVycyc7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LXRyZW5kJyxcbiAgdGVtcGxhdGU6IGBcbiAgPHN2ZyAqbmdJZj1cImRhdGEgJiYgZGF0YS5sZW5ndGggPj0gMlwiXG4gICAgW2F0dHIud2lkdGhdPVwic3ZnV2lkdGhcIlxuICAgIFthdHRyLmhlaWdodF09XCJzdmdIZWlnaHRcIlxuICAgIFthdHRyLnN0cm9rZV09XCJzdHJva2VcIlxuICAgIFthdHRyLnN0cm9rZS13aWR0aF09XCJzdHJva2VXaWR0aFwiXG4gICAgW2F0dHIuc3Ryb2tlLWxpbmVjYXBdPVwic3Ryb2tlTGluZWNhcFwiXG4gICAgW2F0dHIudmlld0JveF09XCJ2aWV3Qm94XCJcbiAgICBbYXR0ci5wcmVzZXJ2ZUFzcGVjdFJhdGlvXT1cInByZXNlcnZlQXNwZWN0UmF0aW9cIlxuICA+XG4gICAgPGRlZnMgKm5nSWY9XCJncmFkaWVudCAmJiBncmFkaWVudC5sZW5ndGhcIj5cbiAgICAgIDxsaW5lYXJHcmFkaWVudCBbYXR0ci5pZF09XCJncmFkaWVudElkXCIgeDE9XCIwJVwiIHkxPVwiMCVcIiB4Mj1cIjAlXCIgeTI9XCIxMDAlXCI+XG4gICAgICAgIDxzdG9wXG4gICAgICAgICAgKm5nRm9yPVwibGV0IGcgb2YgZ3JhZGllbnRUcmltbWVkO1wiXG4gICAgICAgICAgW2F0dHIua2V5XT1cImcuaWR4XCJcbiAgICAgICAgICBbYXR0ci5vZmZzZXRdPVwiZy5vZmZzZXRcIlxuICAgICAgICAgIFthdHRyLnN0b3AtY29sb3JdPVwiZy5zdG9wQ29sb3JcIlxuICAgICAgICAvPlxuICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICA8L2RlZnM+XG4gICAgPHBhdGggZmlsbD1cIm5vbmVcIiAjcGF0aEVsXG4gICAgICBbYXR0ci5zdHJva2VdPVwicGF0aFN0cm9rZVwiIFthdHRyLmRdPVwiZFwiXG4gICAgICBbQHBhdGhBbmltYWl0b25dPVwie1xuICAgICAgICB2YWx1ZTogYW5pbWF0aW9uU3RhdGUsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGF1dG9EcmF3RHVyYXRpb246IGF1dG9EcmF3RHVyYXRpb24sXG4gICAgICAgICAgYXV0b0RyYXdFYXNpbmc6IGF1dG9EcmF3RWFzaW5nLFxuICAgICAgICAgIGxpbmVMZW5ndGg6IGxpbmVMZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVwiIC8+XG4gIDwvc3ZnPlxuICBgLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcigncGF0aEFuaW1haXRvbicsIFtcbiAgICAgIHN0YXRlKCdpbmFjdGl2ZScsIHN0eWxlKHsgZGlzcGxheTogJ25vbmUnIH0pKSxcbiAgICAgIHRyYW5zaXRpb24oJyogPT4gYWN0aXZlJywgW1xuICAgICAgICBzdHlsZSh7IGRpc3BsYXk6ICdpbml0aWFsJyB9KSxcbiAgICAgICAgLy8gV2UgZG8gdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgZGFzaCBhcnJheS9vZmZzZXQgdHJpY2tcbiAgICAgICAgLy8gaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9zdmctbGluZS1hbmltYXRpb24td29ya3MvXG4gICAgICAgIGFuaW1hdGUoJ3t7IGF1dG9EcmF3RHVyYXRpb24gfX1tcyB7eyBhdXRvRHJhd0Vhc2luZyB9fScsXG4gICAgICAgICAga2V5ZnJhbWVzKFtcbiAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAne3sgbGluZUxlbmd0aCB9fXB4JyxcbiAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3t7IGxpbmVMZW5ndGggfX1weCcsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAne3sgbGluZUxlbmd0aCB9fXB4JyxcbiAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogMCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIF0pLFxuICAgICAgICApLFxuICAgICAgICAvLyBPbmUgdW5mb3J0dW5hdGUgc2lkZS1lZmZlY3Qgb2YgdGhlIGF1dG8tZHJhdyBpcyB0aGF0IHRoZSBsaW5lIGlzXG4gICAgICAgIC8vIGFjdHVhbGx5IDEgYmlnIGRhc2gsIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgbGluZSBpdHNlbGYuIElmIHRoZVxuICAgICAgICAvLyBsaW5lIGxlbmd0aCBjaGFuZ2VzIChlZy4gcmFkaXVzIGNoYW5nZSwgbmV3IGRhdGEpLCB0aGF0IGRhc2ggd29uJ3RcbiAgICAgICAgLy8gYmUgdGhlIHNhbWUgbGVuZ3RoIGFueW1vcmUuIFdlIGNhbiBmaXggdGhhdCBieSByZW1vdmluZyB0aG9zZVxuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9uY2UgdGhlIGF1dG8tZHJhdyBpcyBjb21wbGV0ZWQuXG4gICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnJyxcbiAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICcnLFxuICAgICAgICB9KSxcbiAgICAgIF0pLFxuICAgIF0pLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBUcmVuZENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIGlkOiBudW1iZXI7XG4gIEBJbnB1dCgpIGRhdGE6IChudW1iZXIgfCB7dmFsdWU6IG51bWJlcn0pW107XG4gIEBJbnB1dCgpIHNtb290aDogYm9vbGVhbjtcbiAgQElucHV0KCkgYXV0b0RyYXcgPSBmYWxzZTtcbiAgQElucHV0KCkgYXV0b0RyYXdEdXJhdGlvbiA9IDIwMDA7XG4gIEBJbnB1dCgpIGF1dG9EcmF3RWFzaW5nID0gJ2Vhc2UnO1xuICBASW5wdXQoKSB3aWR0aDogbnVtYmVyO1xuICBASW5wdXQoKSBoZWlnaHQ6IG51bWJlcjtcbiAgQElucHV0KCkgcGFkZGluZyA9IDg7XG4gIEBJbnB1dCgpIHJhZGl1cyA9IDEwO1xuICBASW5wdXQoKSBzdHJva2UgPSAnYmxhY2snO1xuICBASW5wdXQoKSBzdHJva2VMaW5lY2FwID0gJyc7XG4gIEBJbnB1dCgpIHN0cm9rZVdpZHRoID0gMTtcbiAgQElucHV0KCkgZ3JhZGllbnQ6IHN0cmluZ1tdID0gW107XG4gIEBJbnB1dCgpIHByZXNlcnZlQXNwZWN0UmF0aW86IHN0cmluZztcbiAgQElucHV0KCkgc3ZnSGVpZ2h0OiBzdHJpbmcgfCBudW1iZXIgPSAnMjUlJztcbiAgQElucHV0KCkgc3ZnV2lkdGg6IHN0cmluZyB8IG51bWJlciA9ICcxMDAlJztcbiAgQFZpZXdDaGlsZCgncGF0aEVsJykgcGF0aEVsOiBFbGVtZW50UmVmO1xuICBncmFkaWVudFRyaW1tZWQ6IGFueVtdO1xuICBkOiBhbnk7XG4gIHZpZXdCb3g6IHN0cmluZztcbiAgcGF0aFN0cm9rZTogYW55O1xuICBncmFkaWVudElkOiBzdHJpbmc7XG4gIGxpbmVMZW5ndGg6IG51bWJlcjtcbiAgYW5pbWF0aW9uU3RhdGUgPSAnJztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIHRoaXMuZ3JhZGllbnRJZCA9IGBuZ3gtdHJlbmQtdmVydGljYWwtZ3JhZGllbnQtJHt0aGlzLmlkfWA7XG4gIH1cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgLy8gV2UgbmVlZCBhdCBsZWFzdCAyIHBvaW50cyB0byBkcmF3IGEgZ3JhcGguXG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBgZGF0YWAgY2FuIGVpdGhlciBiZSBhbiBhcnJheSBvZiBudW1iZXJzOlxuICAgIC8vIFsxLCAyLCAzXVxuICAgIC8vIG9yLCBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYSB2YWx1ZTpcbiAgICAvLyBbeyB2YWx1ZTogMSB9LCB7IHZhbHVlOiAyIH0sIHsgdmFsdWU6IDMgfV1cbiAgICAvL1xuICAgIC8vIEZvciBub3csIHdlJ3JlIGp1c3QgZ29pbmcgdG8gY29udmVydCB0aGUgc2Vjb25kIGZvcm0gdG8gdGhlIGZpcnN0LlxuICAgIC8vIExhdGVyIG9uLCBpZi93aGVuIHdlIHN1cHBvcnQgdG9vbHRpcHMsIHdlIG1heSBhZGp1c3QuXG4gICAgY29uc3QgcGxhaW5WYWx1ZXMgPSB0aGlzLmRhdGEubWFwKChwb2ludCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwb2ludCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50LnZhbHVlO1xuICAgIH0pO1xuXG4gICAgLy8gT3VyIHZpZXdib3ggbmVlZHMgdG8gYmUgaW4gYWJzb2x1dGUgdW5pdHMsIHNvIHdlJ2xsIGRlZmF1bHQgdG8gMzAweDc1XG4gICAgLy8gT3VyIFNWRyBjYW4gYmUgYSAlLCB0aG91Z2g7IHRoaXMgaXMgd2hhdCBtYWtlcyBpdCBzY2FsYWJsZS5cbiAgICAvLyBCeSBkZWZhdWx0aW5nIHRvIHBlcmNlbnRhZ2VzLCB0aGUgU1ZHIHdpbGwgZ3JvdyB0byBmaWxsIGl0cyBwYXJlbnRcbiAgICAvLyBjb250YWluZXIsIHByZXNlcnZpbmcgYSAxLzQgYXNwZWN0IHJhdGlvLlxuICAgIGNvbnN0IHZpZXdCb3hXaWR0aCA9IHRoaXMud2lkdGggfHwgMzAwO1xuICAgIGNvbnN0IHZpZXdCb3hIZWlnaHQgPSB0aGlzLmhlaWdodCB8fCA3NTtcbiAgICB0aGlzLnN2Z1dpZHRoID0gdGhpcy53aWR0aCB8fCAnMTAwJSc7XG4gICAgdGhpcy5zdmdIZWlnaHQgPSB0aGlzLmhlaWdodCB8fCAnMjUlJztcbiAgICB0aGlzLnZpZXdCb3ggPSBgMCAwICR7dmlld0JveFdpZHRofSAke3ZpZXdCb3hIZWlnaHR9YDtcbiAgICBjb25zdCByb290ID0gbG9jYXRpb24uaHJlZi5zcGxpdChsb2NhdGlvbi5oYXNoIHx8ICcjJylbMF07XG4gICAgdGhpcy5wYXRoU3Ryb2tlID0gKHRoaXMuZ3JhZGllbnQgJiYgdGhpcy5ncmFkaWVudC5sZW5ndGgpID8gYHVybCgnJHtyb290fSMke3RoaXMuZ3JhZGllbnRJZH0nKWAgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmdyYWRpZW50VHJpbW1lZCA9IHRoaXMuZ3JhZGllbnQuc2xpY2UoKS5yZXZlcnNlKCkubWFwKCh2YWwsIGlkeCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWR4LFxuICAgICAgICBzdG9wQ29sb3I6IHZhbCxcbiAgICAgICAgb2Zmc2V0OiBub3JtYWxpemUoaWR4LCAwLCB0aGlzLmdyYWRpZW50Lmxlbmd0aCAtIDEgfHwgMSksXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlcyA9IG5vcm1hbGl6ZURhdGFzZXQocGxhaW5WYWx1ZXMsXG4gICAgICB0aGlzLnBhZGRpbmcsXG4gICAgICB2aWV3Qm94V2lkdGggLSB0aGlzLnBhZGRpbmcsXG4gICAgICAvLyBOT1RFOiBCZWNhdXNlIFNWR3MgYXJlIGluZGV4ZWQgZnJvbSB0aGUgdG9wIGxlZnQsIGJ1dCBtb3N0IGRhdGEgaXNcbiAgICAgIC8vIGluZGV4ZWQgZnJvbSB0aGUgYm90dG9tIGxlZnQsIHdlJ3JlIGludmVydGluZyB0aGUgWSBtaW4vbWF4LlxuICAgICAgdmlld0JveEhlaWdodCAtIHRoaXMucGFkZGluZyxcbiAgICAgIHRoaXMucGFkZGluZyxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuYXV0b0RyYXcgJiYgdGhpcy5hbmltYXRpb25TdGF0ZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAnaW5hY3RpdmUnO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IHRoaXMucGF0aEVsLm5hdGl2ZUVsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9ICdhY3RpdmUnO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5kID0gdGhpcy5zbW9vdGhcbiAgICAgID8gYnVpbGRTbW9vdGhQYXRoKG5vcm1hbGl6ZWRWYWx1ZXMsIHRoaXMucmFkaXVzKVxuICAgICAgOiBidWlsZExpbmVhclBhdGgobm9ybWFsaXplZFZhbHVlcyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBUcmVuZENvbXBvbmVudCB9IGZyb20gJy4vdHJlbmQuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGV4cG9ydHM6IFtUcmVuZENvbXBvbmVudF0sXG4gIGRlY2xhcmF0aW9uczogW1RyZW5kQ29tcG9uZW50XSxcbn0pXG5leHBvcnQgY2xhc3MgVHJlbmRNb2R1bGUge1xufVxuIl19","map":null,"metadata":{},"sourceType":"module"}