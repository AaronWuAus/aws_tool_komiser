{"ast":null,"code":"/*!\n *\n * Jquery Mapael - Dynamic maps jQuery plugin (based on raphael.js)\n * Requires jQuery, raphael.js and jquery.mousewheel\n *\n * Version: 2.2.0\n *\n * Copyright (c) 2017 Vincent Brout√© (https://www.vincentbroute.fr/mapael)\n * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php).\n *\n * Thanks to Indigo744\n *\n */\n(function (factory) {\n  if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = factory(require('jquery'), require('raphael'), require('jquery-mousewheel'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['jquery', 'raphael', 'mousewheel'], factory);\n  } else {\n    // Browser globals\n    factory(jQuery, Raphael, jQuery.fn.mousewheel);\n  }\n})(function ($, Raphael, mousewheel, undefined) {\n  \"use strict\"; // The plugin name (used on several places)\n\n  var pluginName = \"mapael\"; // Version number of jQuery Mapael. See http://semver.org/ for more information.\n\n  var version = \"2.2.0\";\n  /*\n   * Mapael constructor\n   * Init instance vars and call init()\n   * @param container the DOM element on which to apply the plugin\n   * @param options the complete options to use\n   */\n\n  var Mapael = function Mapael(container, options) {\n    var self = this; // the global container (DOM element object)\n\n    self.container = container; // the global container (jQuery object)\n\n    self.$container = $(container); // the global options\n\n    self.options = self.extendDefaultOptions(options); // zoom TimeOut handler (used to set and clear)\n\n    self.zoomTO = 0; // zoom center coordinate (set at touchstart)\n\n    self.zoomCenterX = 0;\n    self.zoomCenterY = 0; // Zoom pinch (set at touchstart and touchmove)\n\n    self.previousPinchDist = 0; // Zoom data\n\n    self.zoomData = {\n      zoomLevel: 0,\n      zoomX: 0,\n      zoomY: 0,\n      panX: 0,\n      panY: 0\n    };\n    self.currentViewBox = {\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    }; // Panning: tell if panning action is in progress\n\n    self.panning = false; // Animate view box\n\n    self.zoomAnimID = null; // Interval handler (used to set and clear)\n\n    self.zoomAnimStartTime = null; // Animation start time\n\n    self.zoomAnimCVBTarget = null; // Current ViewBox target\n    // Map subcontainer jQuery object\n\n    self.$map = $(\".\" + self.options.map.cssClass, self.container); // Save initial HTML content (used by destroy method)\n\n    self.initialMapHTMLContent = self.$map.html(); // The tooltip jQuery object\n\n    self.$tooltip = {}; // The paper Raphael object\n\n    self.paper = {}; // The areas object list\n\n    self.areas = {}; // The plots object list\n\n    self.plots = {}; // The links object list\n\n    self.links = {}; // The legends list\n\n    self.legends = {}; // The map configuration object (taken from map file)\n\n    self.mapConf = {}; // Holds all custom event handlers\n\n    self.customEventHandlers = {}; // Let's start the initialization\n\n    self.init();\n  };\n  /*\n   * Mapael Prototype\n   * Defines all methods and properties needed by Mapael\n   * Each mapael object inherits their properties and methods from this prototype\n   */\n\n\n  Mapael.prototype = {\n    /* Filtering TimeOut value in ms\n     * Used for mouseover trigger over elements */\n    MouseOverFilteringTO: 120,\n\n    /* Filtering TimeOut value in ms\n     * Used for afterPanning trigger when panning */\n    panningFilteringTO: 150,\n\n    /* Filtering TimeOut value in ms\n     * Used for mouseup/touchend trigger when panning */\n    panningEndFilteringTO: 50,\n\n    /* Filtering TimeOut value in ms\n     * Used for afterZoom trigger when zooming */\n    zoomFilteringTO: 150,\n\n    /* Filtering TimeOut value in ms\n     * Used for when resizing window */\n    resizeFilteringTO: 150,\n\n    /*\n     * Initialize the plugin\n     * Called by the constructor\n     */\n    init: function init() {\n      var self = this; // Init check for class existence\n\n      if (self.options.map.cssClass === \"\" || $(\".\" + self.options.map.cssClass, self.container).length === 0) {\n        throw new Error(\"The map class `\" + self.options.map.cssClass + \"` doesn't exists\");\n      } // Create the tooltip container\n\n\n      self.$tooltip = $(\"<div>\").addClass(self.options.map.tooltip.cssClass).css(\"display\", \"none\"); // Get the map container, empty it then append tooltip\n\n      self.$map.empty().append(self.$tooltip); // Get the map from $.mapael or $.fn.mapael (backward compatibility)\n\n      if ($[pluginName] && $[pluginName].maps && $[pluginName].maps[self.options.map.name]) {\n        // Mapael version >= 2.x\n        self.mapConf = $[pluginName].maps[self.options.map.name];\n      } else if ($.fn[pluginName] && $.fn[pluginName].maps && $.fn[pluginName].maps[self.options.map.name]) {\n        // Mapael version <= 1.x - DEPRECATED\n        self.mapConf = $.fn[pluginName].maps[self.options.map.name];\n\n        if (window.console && window.console.warn) {\n          window.console.warn(\"Extending $.fn.mapael is deprecated (map '\" + self.options.map.name + \"')\");\n        }\n      } else {\n        throw new Error(\"Unknown map '\" + self.options.map.name + \"'\");\n      } // Create Raphael paper\n\n\n      self.paper = new Raphael(self.$map[0], self.mapConf.width, self.mapConf.height); // issue #135: Check for Raphael bug on text element boundaries\n\n      if (self.isRaphaelBBoxBugPresent() === true) {\n        self.destroy();\n        throw new Error(\"Can't get boundary box for text (is your container hidden? See #135)\");\n      } // add plugin class name on element\n\n\n      self.$container.addClass(pluginName);\n      if (self.options.map.tooltip.css) self.$tooltip.css(self.options.map.tooltip.css);\n      self.setViewBox(0, 0, self.mapConf.width, self.mapConf.height); // Handle map size\n\n      if (self.options.map.width) {\n        // NOT responsive: map has a fixed width\n        self.paper.setSize(self.options.map.width, self.mapConf.height * (self.options.map.width / self.mapConf.width));\n      } else {\n        // Responsive: handle resizing of the map\n        self.initResponsiveSize();\n      } // Draw map areas\n\n\n      $.each(self.mapConf.elems, function (id) {\n        // Init area object\n        self.areas[id] = {}; // Set area options\n\n        self.areas[id].options = self.getElemOptions(self.options.map.defaultArea, self.options.areas[id] ? self.options.areas[id] : {}, self.options.legend.area); // draw area\n\n        self.areas[id].mapElem = self.paper.path(self.mapConf.elems[id]);\n      }); // Hook that allows to add custom processing on the map\n\n      if (self.options.map.beforeInit) self.options.map.beforeInit(self.$container, self.paper, self.options); // Init map areas in a second loop\n      // Allows text to be added after ALL areas and prevent them from being hidden\n\n      $.each(self.mapConf.elems, function (id) {\n        self.initElem(id, 'area', self.areas[id]);\n      }); // Draw links\n\n      self.links = self.drawLinksCollection(self.options.links); // Draw plots\n\n      $.each(self.options.plots, function (id) {\n        self.plots[id] = self.drawPlot(id);\n      }); // Attach zoom event\n\n      self.$container.on(\"zoom.\" + pluginName, function (e, zoomOptions) {\n        self.onZoomEvent(e, zoomOptions);\n      });\n\n      if (self.options.map.zoom.enabled) {\n        // Enable zoom\n        self.initZoom(self.mapConf.width, self.mapConf.height, self.options.map.zoom);\n      } // Set initial zoom\n\n\n      if (self.options.map.zoom.init !== undefined) {\n        if (self.options.map.zoom.init.animDuration === undefined) {\n          self.options.map.zoom.init.animDuration = 0;\n        }\n\n        self.$container.trigger(\"zoom\", self.options.map.zoom.init);\n      } // Create the legends for areas\n\n\n      self.createLegends(\"area\", self.areas, 1); // Create the legends for plots taking into account the scale of the map\n\n      self.createLegends(\"plot\", self.plots, self.paper.width / self.mapConf.width); // Attach update event\n\n      self.$container.on(\"update.\" + pluginName, function (e, opt) {\n        self.onUpdateEvent(e, opt);\n      }); // Attach showElementsInRange event\n\n      self.$container.on(\"showElementsInRange.\" + pluginName, function (e, opt) {\n        self.onShowElementsInRange(e, opt);\n      }); // Attach delegated events\n\n      self.initDelegatedMapEvents(); // Attach delegated custom events\n\n      self.initDelegatedCustomEvents(); // Hook that allows to add custom processing on the map\n\n      if (self.options.map.afterInit) self.options.map.afterInit(self.$container, self.paper, self.areas, self.plots, self.options);\n      $(self.paper.desc).append(\" and Mapael \" + self.version + \" (https://www.vincentbroute.fr/mapael/)\");\n    },\n\n    /*\n     * Destroy mapael\n     * This function effectively detach mapael from the container\n     *   - Set the container back to the way it was before mapael instanciation\n     *   - Remove all data associated to it (memory can then be free'ed by browser)\n     *\n     * This method can be call directly by user:\n     *     $(\".mapcontainer\").data(\"mapael\").destroy();\n     *\n     * This method is also automatically called if the user try to call mapael\n     * on a container already containing a mapael instance\n     */\n    destroy: function destroy() {\n      var self = this; // Detach all event listeners attached to the container\n\n      self.$container.off(\".\" + pluginName);\n      self.$map.off(\".\" + pluginName); // Detach the global resize event handler\n\n      if (self.onResizeEvent) $(window).off(\"resize.\" + pluginName, self.onResizeEvent); // Empty the container (this will also detach all event listeners)\n\n      self.$map.empty(); // Replace initial HTML content\n\n      self.$map.html(self.initialMapHTMLContent); // Empty legend containers and replace initial HTML content\n\n      $.each(self.legends, function (legendType) {\n        $.each(self.legends[legendType], function (legendIndex) {\n          var legend = self.legends[legendType][legendIndex];\n          legend.container.empty();\n          legend.container.html(legend.initialHTMLContent);\n        });\n      }); // Remove mapael class\n\n      self.$container.removeClass(pluginName); // Remove the data\n\n      self.$container.removeData(pluginName); // Remove all internal reference\n\n      self.container = undefined;\n      self.$container = undefined;\n      self.options = undefined;\n      self.paper = undefined;\n      self.$map = undefined;\n      self.$tooltip = undefined;\n      self.mapConf = undefined;\n      self.areas = undefined;\n      self.plots = undefined;\n      self.links = undefined;\n      self.customEventHandlers = undefined;\n    },\n    initResponsiveSize: function initResponsiveSize() {\n      var self = this;\n      var resizeTO = null; // Function that actually handle the resizing\n\n      var handleResize = function handleResize(isInit) {\n        var containerWidth = self.$map.width();\n\n        if (self.paper.width !== containerWidth) {\n          var newScale = containerWidth / self.mapConf.width; // Set new size\n\n          self.paper.setSize(containerWidth, self.mapConf.height * newScale); // Create plots legend again to take into account the new scale\n          // Do not do this on init (it will be done later)\n\n          if (isInit !== true && self.options.legend.redrawOnResize) {\n            self.createLegends(\"plot\", self.plots, newScale);\n          }\n        }\n      };\n\n      self.onResizeEvent = function () {\n        // Clear any previous setTimeout (avoid too much triggering)\n        clearTimeout(resizeTO); // setTimeout to wait for the user to finish its resizing\n\n        resizeTO = setTimeout(function () {\n          handleResize();\n        }, self.resizeFilteringTO);\n      }; // Attach resize handler\n\n\n      $(window).on(\"resize.\" + pluginName, self.onResizeEvent); // Call once\n\n      handleResize(true);\n    },\n\n    /*\n     * Extend the user option with the default one\n     * @param options the user options\n     * @return new options object\n     */\n    extendDefaultOptions: function extendDefaultOptions(options) {\n      // Extend default options with user options\n      options = $.extend(true, {}, Mapael.prototype.defaultOptions, options); // Extend legend default options\n\n      $.each(['area', 'plot'], function (key, type) {\n        if ($.isArray(options.legend[type])) {\n          for (var i = 0; i < options.legend[type].length; ++i) {\n            options.legend[type][i] = $.extend(true, {}, Mapael.prototype.legendDefaultOptions[type], options.legend[type][i]);\n          }\n        } else {\n          options.legend[type] = $.extend(true, {}, Mapael.prototype.legendDefaultOptions[type], options.legend[type]);\n        }\n      });\n      return options;\n    },\n\n    /*\n     * Init all delegated events for the whole map:\n     *  mouseover\n     *  mousemove\n     *  mouseout\n     */\n    initDelegatedMapEvents: function initDelegatedMapEvents() {\n      var self = this; // Mapping between data-type value and the corresponding elements array\n      // Note: legend-elem and legend-label are not in this table because\n      //       they need a special processing\n\n      var dataTypeToElementMapping = {\n        'area': self.areas,\n        'area-text': self.areas,\n        'plot': self.plots,\n        'plot-text': self.plots,\n        'link': self.links,\n        'link-text': self.links\n      };\n      /* Attach mouseover event delegation\n       * Note: we filter the event with a timeout to reduce the firing when the mouse moves quickly\n       */\n\n      var mapMouseOverTimeoutID;\n      self.$container.on(\"mouseover.\" + pluginName, \"[data-id]\", function () {\n        var elem = this;\n        clearTimeout(mapMouseOverTimeoutID);\n        mapMouseOverTimeoutID = setTimeout(function () {\n          var $elem = $(elem);\n          var id = $elem.attr('data-id');\n          var type = $elem.attr('data-type');\n\n          if (dataTypeToElementMapping[type] !== undefined) {\n            self.elemEnter(dataTypeToElementMapping[type][id]);\n          } else if (type === 'legend-elem' || type === 'legend-label') {\n            var legendIndex = $elem.attr('data-legend-id');\n            var legendType = $elem.attr('data-legend-type');\n            self.elemEnter(self.legends[legendType][legendIndex].elems[id]);\n          }\n        }, self.MouseOverFilteringTO);\n      });\n      /* Attach mousemove event delegation\n       * Note: timeout filtering is small to update the Tooltip position fast\n       */\n\n      var mapMouseMoveTimeoutID;\n      self.$container.on(\"mousemove.\" + pluginName, \"[data-id]\", function (event) {\n        var elem = this;\n        clearTimeout(mapMouseMoveTimeoutID);\n        mapMouseMoveTimeoutID = setTimeout(function () {\n          var $elem = $(elem);\n          var id = $elem.attr('data-id');\n          var type = $elem.attr('data-type');\n\n          if (dataTypeToElementMapping[type] !== undefined) {\n            self.elemHover(dataTypeToElementMapping[type][id], event);\n          } else if (type === 'legend-elem' || type === 'legend-label') {\n            /* Nothing to do */\n          }\n        }, 0);\n      });\n      /* Attach mouseout event delegation\n       * Note: we don't perform any timeout filtering to clear & reset elem ASAP\n       * Otherwise an element may be stuck in 'hover' state (which is NOT good)\n       */\n\n      self.$container.on(\"mouseout.\" + pluginName, \"[data-id]\", function () {\n        var elem = this; // Clear any\n\n        clearTimeout(mapMouseOverTimeoutID);\n        clearTimeout(mapMouseMoveTimeoutID);\n        var $elem = $(elem);\n        var id = $elem.attr('data-id');\n        var type = $elem.attr('data-type');\n\n        if (dataTypeToElementMapping[type] !== undefined) {\n          self.elemOut(dataTypeToElementMapping[type][id]);\n        } else if (type === 'legend-elem' || type === 'legend-label') {\n          var legendIndex = $elem.attr('data-legend-id');\n          var legendType = $elem.attr('data-legend-type');\n          self.elemOut(self.legends[legendType][legendIndex].elems[id]);\n        }\n      });\n      /* Attach click event delegation\n       * Note: we filter the event with a timeout to avoid double click\n       */\n\n      self.$container.on(\"click.\" + pluginName, \"[data-id]\", function (evt, opts) {\n        var $elem = $(this);\n        var id = $elem.attr('data-id');\n        var type = $elem.attr('data-type');\n\n        if (dataTypeToElementMapping[type] !== undefined) {\n          self.elemClick(dataTypeToElementMapping[type][id]);\n        } else if (type === 'legend-elem' || type === 'legend-label') {\n          var legendIndex = $elem.attr('data-legend-id');\n          var legendType = $elem.attr('data-legend-type');\n          self.handleClickOnLegendElem(self.legends[legendType][legendIndex].elems[id], id, legendIndex, legendType, opts);\n        }\n      });\n    },\n\n    /*\n     * Init all delegated custom events\n     */\n    initDelegatedCustomEvents: function initDelegatedCustomEvents() {\n      var self = this;\n      $.each(self.customEventHandlers, function (eventName) {\n        // Namespace the custom event\n        // This allow to easily unbound only custom events and not regular ones\n        var fullEventName = eventName + '.' + pluginName + \".custom\";\n        self.$container.off(fullEventName).on(fullEventName, \"[data-id]\", function (e) {\n          var $elem = $(this);\n          var id = $elem.attr('data-id');\n          var type = $elem.attr('data-type').replace('-text', '');\n\n          if (!self.panning && self.customEventHandlers[eventName][type] !== undefined && self.customEventHandlers[eventName][type][id] !== undefined) {\n            // Get back related elem\n            var elem = self.customEventHandlers[eventName][type][id]; // Run callback provided by user\n\n            elem.options.eventHandlers[eventName](e, id, elem.mapElem, elem.textElem, elem.options);\n          }\n        });\n      });\n    },\n\n    /*\n     * Init the element \"elem\" on the map (drawing text, setting attributes, events, tooltip, ...)\n     *\n     * @param id the id of the element\n     * @param type the type of the element (area, plot, link)\n     * @param elem object the element object (with mapElem), it will be updated\n     */\n    initElem: function initElem(id, type, elem) {\n      var self = this;\n      var $mapElem = $(elem.mapElem.node); // If an HTML link exists for this element, add cursor attributes\n\n      if (elem.options.href) {\n        elem.options.attrs.cursor = \"pointer\";\n        if (elem.options.text) elem.options.text.attrs.cursor = \"pointer\";\n      } // Set SVG attributes to map element\n\n\n      elem.mapElem.attr(elem.options.attrs); // Set DOM attributes to map element\n\n      $mapElem.attr({\n        \"data-id\": id,\n        \"data-type\": type\n      });\n\n      if (elem.options.cssClass !== undefined) {\n        $mapElem.addClass(elem.options.cssClass);\n      } // Init the label related to the element\n\n\n      if (elem.options.text && elem.options.text.content !== undefined) {\n        // Set a text label in the area\n        var textPosition = self.getTextPosition(elem.mapElem.getBBox(), elem.options.text.position, elem.options.text.margin);\n        elem.options.text.attrs.text = elem.options.text.content;\n        elem.options.text.attrs.x = textPosition.x;\n        elem.options.text.attrs.y = textPosition.y;\n        elem.options.text.attrs['text-anchor'] = textPosition.textAnchor; // Draw text\n\n        elem.textElem = self.paper.text(textPosition.x, textPosition.y, elem.options.text.content); // Apply SVG attributes to text element\n\n        elem.textElem.attr(elem.options.text.attrs); // Apply DOM attributes\n\n        $(elem.textElem.node).attr({\n          \"data-id\": id,\n          \"data-type\": type + '-text'\n        });\n      } // Set user event handlers\n\n\n      if (elem.options.eventHandlers) self.setEventHandlers(id, type, elem); // Set hover option for mapElem\n\n      self.setHoverOptions(elem.mapElem, elem.options.attrs, elem.options.attrsHover); // Set hover option for textElem\n\n      if (elem.textElem) self.setHoverOptions(elem.textElem, elem.options.text.attrs, elem.options.text.attrsHover);\n    },\n\n    /*\n     * Init zoom and panning for the map\n     * @param mapWidth\n     * @param mapHeight\n     * @param zoomOptions\n     */\n    initZoom: function initZoom(mapWidth, mapHeight, zoomOptions) {\n      var self = this;\n      var mousedown = false;\n      var previousX = 0;\n      var previousY = 0;\n      var fnZoomButtons = {\n        \"reset\": function reset() {\n          self.$container.trigger(\"zoom\", {\n            \"level\": 0\n          });\n        },\n        \"in\": function _in() {\n          self.$container.trigger(\"zoom\", {\n            \"level\": \"+1\"\n          });\n        },\n        \"out\": function out() {\n          self.$container.trigger(\"zoom\", {\n            \"level\": -1\n          });\n        }\n      }; // init Zoom data\n\n      $.extend(self.zoomData, {\n        zoomLevel: 0,\n        panX: 0,\n        panY: 0\n      }); // init zoom buttons\n\n      $.each(zoomOptions.buttons, function (type, opt) {\n        if (fnZoomButtons[type] === undefined) throw new Error(\"Unknown zoom button '\" + type + \"'\"); // Create div with classes, contents and title (for tooltip)\n\n        var $button = $(\"<div>\").addClass(opt.cssClass).html(opt.content).attr(\"title\", opt.title); // Assign click event\n\n        $button.on(\"click.\" + pluginName, fnZoomButtons[type]); // Append to map\n\n        self.$map.append($button);\n      }); // Update the zoom level of the map on mousewheel\n\n      if (self.options.map.zoom.mousewheel) {\n        self.$map.on(\"mousewheel.\" + pluginName, function (e) {\n          var zoomLevel = e.deltaY > 0 ? 1 : -1;\n          var coord = self.mapPagePositionToXY(e.pageX, e.pageY);\n          self.$container.trigger(\"zoom\", {\n            \"fixedCenter\": true,\n            \"level\": self.zoomData.zoomLevel + zoomLevel,\n            \"x\": coord.x,\n            \"y\": coord.y\n          });\n          e.preventDefault();\n        });\n      } // Update the zoom level of the map on touch pinch\n\n\n      if (self.options.map.zoom.touch) {\n        self.$map.on(\"touchstart.\" + pluginName, function (e) {\n          if (e.originalEvent.touches.length === 2) {\n            self.zoomCenterX = (e.originalEvent.touches[0].pageX + e.originalEvent.touches[1].pageX) / 2;\n            self.zoomCenterY = (e.originalEvent.touches[0].pageY + e.originalEvent.touches[1].pageY) / 2;\n            self.previousPinchDist = Math.sqrt(Math.pow(e.originalEvent.touches[1].pageX - e.originalEvent.touches[0].pageX, 2) + Math.pow(e.originalEvent.touches[1].pageY - e.originalEvent.touches[0].pageY, 2));\n          }\n        });\n        self.$map.on(\"touchmove.\" + pluginName, function (e) {\n          var pinchDist = 0;\n          var zoomLevel = 0;\n\n          if (e.originalEvent.touches.length === 2) {\n            pinchDist = Math.sqrt(Math.pow(e.originalEvent.touches[1].pageX - e.originalEvent.touches[0].pageX, 2) + Math.pow(e.originalEvent.touches[1].pageY - e.originalEvent.touches[0].pageY, 2));\n\n            if (Math.abs(pinchDist - self.previousPinchDist) > 15) {\n              var coord = self.mapPagePositionToXY(self.zoomCenterX, self.zoomCenterY);\n              zoomLevel = (pinchDist - self.previousPinchDist) / Math.abs(pinchDist - self.previousPinchDist);\n              self.$container.trigger(\"zoom\", {\n                \"fixedCenter\": true,\n                \"level\": self.zoomData.zoomLevel + zoomLevel,\n                \"x\": coord.x,\n                \"y\": coord.y\n              });\n              self.previousPinchDist = pinchDist;\n            }\n\n            return false;\n          }\n        });\n      } // When the user drag the map, prevent to move the clicked element instead of dragging the map (behaviour seen with Firefox)\n\n\n      self.$map.on(\"dragstart\", function () {\n        return false;\n      }); // Panning\n\n      var panningMouseUpTO = null;\n      var panningMouseMoveTO = null;\n      $(\"body\").on(\"mouseup.\" + pluginName + (zoomOptions.touch ? \" touchend.\" + pluginName : \"\"), function () {\n        mousedown = false;\n        clearTimeout(panningMouseUpTO);\n        clearTimeout(panningMouseMoveTO);\n        panningMouseUpTO = setTimeout(function () {\n          self.panning = false;\n        }, self.panningEndFilteringTO);\n      });\n      self.$map.on(\"mousedown.\" + pluginName + (zoomOptions.touch ? \" touchstart.\" + pluginName : \"\"), function (e) {\n        clearTimeout(panningMouseUpTO);\n        clearTimeout(panningMouseMoveTO);\n\n        if (e.pageX !== undefined) {\n          mousedown = true;\n          previousX = e.pageX;\n          previousY = e.pageY;\n        } else {\n          if (e.originalEvent.touches.length === 1) {\n            mousedown = true;\n            previousX = e.originalEvent.touches[0].pageX;\n            previousY = e.originalEvent.touches[0].pageY;\n          }\n        }\n      }).on(\"mousemove.\" + pluginName + (zoomOptions.touch ? \" touchmove.\" + pluginName : \"\"), function (e) {\n        var currentLevel = self.zoomData.zoomLevel;\n        var pageX = 0;\n        var pageY = 0;\n        clearTimeout(panningMouseUpTO);\n        clearTimeout(panningMouseMoveTO);\n\n        if (e.pageX !== undefined) {\n          pageX = e.pageX;\n          pageY = e.pageY;\n        } else {\n          if (e.originalEvent.touches.length === 1) {\n            pageX = e.originalEvent.touches[0].pageX;\n            pageY = e.originalEvent.touches[0].pageY;\n          } else {\n            mousedown = false;\n          }\n        }\n\n        if (mousedown && currentLevel !== 0) {\n          var offsetX = (previousX - pageX) / (1 + currentLevel * zoomOptions.step) * (mapWidth / self.paper.width);\n          var offsetY = (previousY - pageY) / (1 + currentLevel * zoomOptions.step) * (mapHeight / self.paper.height);\n          var panX = Math.min(Math.max(0, self.currentViewBox.x + offsetX), mapWidth - self.currentViewBox.w);\n          var panY = Math.min(Math.max(0, self.currentViewBox.y + offsetY), mapHeight - self.currentViewBox.h);\n\n          if (Math.abs(offsetX) > 5 || Math.abs(offsetY) > 5) {\n            $.extend(self.zoomData, {\n              panX: panX,\n              panY: panY,\n              zoomX: panX + self.currentViewBox.w / 2,\n              zoomY: panY + self.currentViewBox.h / 2\n            });\n            self.setViewBox(panX, panY, self.currentViewBox.w, self.currentViewBox.h);\n            panningMouseMoveTO = setTimeout(function () {\n              self.$map.trigger(\"afterPanning\", {\n                x1: panX,\n                y1: panY,\n                x2: panX + self.currentViewBox.w,\n                y2: panY + self.currentViewBox.h\n              });\n            }, self.panningFilteringTO);\n            previousX = pageX;\n            previousY = pageY;\n            self.panning = true;\n          }\n\n          return false;\n        }\n      });\n    },\n\n    /*\n     * Map a mouse position to a map position\n     *      Transformation principle:\n     *          ** start with (pageX, pageY) absolute mouse coordinate\n     *          - Apply translation: take into accounts the map offset in the page\n     *          ** from this point, we have relative mouse coordinate\n     *          - Apply homothetic transformation: take into accounts initial factor of map sizing (fullWidth / actualWidth)\n     *          - Apply homothetic transformation: take into accounts the zoom factor\n     *          ** from this point, we have relative map coordinate\n     *          - Apply translation: take into accounts the current panning of the map\n     *          ** from this point, we have absolute map coordinate\n     * @param pageX: mouse client coordinate on X\n     * @param pageY: mouse client coordinate on Y\n     * @return map coordinate {x, y}\n     */\n    mapPagePositionToXY: function mapPagePositionToXY(pageX, pageY) {\n      var self = this;\n      var offset = self.$map.offset();\n      var initFactor = self.options.map.width ? self.mapConf.width / self.options.map.width : self.mapConf.width / self.$map.width();\n      var zoomFactor = 1 / (1 + self.zoomData.zoomLevel * self.options.map.zoom.step);\n      return {\n        x: zoomFactor * initFactor * (pageX - offset.left) + self.zoomData.panX,\n        y: zoomFactor * initFactor * (pageY - offset.top) + self.zoomData.panY\n      };\n    },\n\n    /*\n     * Zoom on the map\n     *\n     * zoomOptions.animDuration zoom duration\n     *\n     * zoomOptions.level        level of the zoom between minLevel and maxLevel (absolute number, or relative string +1 or -1)\n     * zoomOptions.fixedCenter  set to true in order to preserve the position of x,y in the canvas when zoomed\n     *\n     * zoomOptions.x            x coordinate of the point to focus on\n     * zoomOptions.y            y coordinate of the point to focus on\n     * - OR -\n     * zoomOptions.latitude     latitude of the point to focus on\n     * zoomOptions.longitude    longitude of the point to focus on\n     * - OR -\n     * zoomOptions.plot         plot ID to focus on\n     * - OR -\n     * zoomOptions.area         area ID to focus on\n     * zoomOptions.areaMargin   margin (in pixels) around the area\n     *\n     * If an area ID is specified, the algorithm will override the zoom level to focus on the area\n     * but it may be limited by the min/max zoom level limits set at initialization.\n     *\n     * If no coordinates are specified, the zoom will be focused on the center of the current view box\n     *\n     */\n    onZoomEvent: function onZoomEvent(e, zoomOptions) {\n      var self = this; // new Top/Left corner coordinates\n\n      var panX;\n      var panY; // new Width/Height viewbox size\n\n      var panWidth;\n      var panHeight; // Zoom level in absolute scale (from 0 to max, by step of 1)\n\n      var zoomLevel = self.zoomData.zoomLevel; // Relative zoom level (from 1 to max, by step of 0.25 (default))\n\n      var previousRelativeZoomLevel = 1 + self.zoomData.zoomLevel * self.options.map.zoom.step;\n      var relativeZoomLevel;\n      var animDuration = zoomOptions.animDuration !== undefined ? zoomOptions.animDuration : self.options.map.zoom.animDuration;\n\n      if (zoomOptions.area !== undefined) {\n        /* An area is given\n         * We will define x/y coordinate AND a new zoom level to fill the area\n         */\n        if (self.areas[zoomOptions.area] === undefined) throw new Error(\"Unknown area '\" + zoomOptions.area + \"'\");\n        var areaMargin = zoomOptions.areaMargin !== undefined ? zoomOptions.areaMargin : 10;\n        var areaBBox = self.areas[zoomOptions.area].mapElem.getBBox();\n        var areaFullWidth = areaBBox.width + 2 * areaMargin;\n        var areaFullHeight = areaBBox.height + 2 * areaMargin; // Compute new x/y focus point (center of area)\n\n        zoomOptions.x = areaBBox.cx;\n        zoomOptions.y = areaBBox.cy; // Compute a new absolute zoomLevel value (inverse of relative -> absolute)\n        // Take the min between zoomLevel on width vs. height to be able to see the whole area\n\n        zoomLevel = Math.min(Math.floor((self.mapConf.width / areaFullWidth - 1) / self.options.map.zoom.step), Math.floor((self.mapConf.height / areaFullHeight - 1) / self.options.map.zoom.step));\n      } else {\n        // Get user defined zoom level\n        if (zoomOptions.level !== undefined) {\n          if (typeof zoomOptions.level === \"string\") {\n            // level is a string, either \"n\", \"+n\" or \"-n\"\n            if (zoomOptions.level.slice(0, 1) === '+' || zoomOptions.level.slice(0, 1) === '-') {\n              // zoomLevel is relative\n              zoomLevel = self.zoomData.zoomLevel + parseInt(zoomOptions.level, 10);\n            } else {\n              // zoomLevel is absolute\n              zoomLevel = parseInt(zoomOptions.level, 10);\n            }\n          } else {\n            // level is integer\n            if (zoomOptions.level < 0) {\n              // zoomLevel is relative\n              zoomLevel = self.zoomData.zoomLevel + zoomOptions.level;\n            } else {\n              // zoomLevel is absolute\n              zoomLevel = zoomOptions.level;\n            }\n          }\n        }\n\n        if (zoomOptions.plot !== undefined) {\n          if (self.plots[zoomOptions.plot] === undefined) throw new Error(\"Unknown plot '\" + zoomOptions.plot + \"'\");\n          zoomOptions.x = self.plots[zoomOptions.plot].coords.x;\n          zoomOptions.y = self.plots[zoomOptions.plot].coords.y;\n        } else {\n          if (zoomOptions.latitude !== undefined && zoomOptions.longitude !== undefined) {\n            var coords = self.mapConf.getCoords(zoomOptions.latitude, zoomOptions.longitude);\n            zoomOptions.x = coords.x;\n            zoomOptions.y = coords.y;\n          }\n\n          if (zoomOptions.x === undefined) {\n            zoomOptions.x = self.currentViewBox.x + self.currentViewBox.w / 2;\n          }\n\n          if (zoomOptions.y === undefined) {\n            zoomOptions.y = self.currentViewBox.y + self.currentViewBox.h / 2;\n          }\n        }\n      } // Make sure we stay in the zoom level boundaries\n\n\n      zoomLevel = Math.min(Math.max(zoomLevel, self.options.map.zoom.minLevel), self.options.map.zoom.maxLevel); // Compute relative zoom level\n\n      relativeZoomLevel = 1 + zoomLevel * self.options.map.zoom.step; // Compute panWidth / panHeight\n\n      panWidth = self.mapConf.width / relativeZoomLevel;\n      panHeight = self.mapConf.height / relativeZoomLevel;\n\n      if (zoomLevel === 0) {\n        panX = 0;\n        panY = 0;\n      } else {\n        if (zoomOptions.fixedCenter !== undefined && zoomOptions.fixedCenter === true) {\n          panX = self.zoomData.panX + (zoomOptions.x - self.zoomData.panX) * (relativeZoomLevel - previousRelativeZoomLevel) / relativeZoomLevel;\n          panY = self.zoomData.panY + (zoomOptions.y - self.zoomData.panY) * (relativeZoomLevel - previousRelativeZoomLevel) / relativeZoomLevel;\n        } else {\n          panX = zoomOptions.x - panWidth / 2;\n          panY = zoomOptions.y - panHeight / 2;\n        } // Make sure we stay in the map boundaries\n\n\n        panX = Math.min(Math.max(0, panX), self.mapConf.width - panWidth);\n        panY = Math.min(Math.max(0, panY), self.mapConf.height - panHeight);\n      } // Update zoom level of the map\n\n\n      if (relativeZoomLevel === previousRelativeZoomLevel && panX === self.zoomData.panX && panY === self.zoomData.panY) return;\n\n      if (animDuration > 0) {\n        self.animateViewBox(panX, panY, panWidth, panHeight, animDuration, self.options.map.zoom.animEasing);\n      } else {\n        self.setViewBox(panX, panY, panWidth, panHeight);\n        clearTimeout(self.zoomTO);\n        self.zoomTO = setTimeout(function () {\n          self.$map.trigger(\"afterZoom\", {\n            x1: panX,\n            y1: panY,\n            x2: panX + panWidth,\n            y2: panY + panHeight\n          });\n        }, self.zoomFilteringTO);\n      }\n\n      $.extend(self.zoomData, {\n        zoomLevel: zoomLevel,\n        panX: panX,\n        panY: panY,\n        zoomX: panX + panWidth / 2,\n        zoomY: panY + panHeight / 2\n      });\n    },\n\n    /*\n     * Show some element in range defined by user\n     * Triggered by user $(\".mapcontainer\").trigger(\"showElementsInRange\", [opt]);\n     *\n     * @param opt the options\n     *  opt.hiddenOpacity opacity for hidden element (default = 0.3)\n     *  opt.animDuration animation duration in ms (default = 0)\n     *  opt.afterShowRange callback\n     *  opt.ranges the range to show:\n     *  Example:\n     *  opt.ranges = {\n     *      'plot' : {\n     *          0 : {                        // valueIndex\n     *              'min': 1000,\n     *              'max': 1200\n     *          },\n     *          1 : {                        // valueIndex\n     *              'min': 10,\n     *              'max': 12\n     *          }\n     *      },\n     *      'area' : {\n     *          {'min': 10, 'max': 20}    // No valueIndex, only an object, use 0 as valueIndex (easy case)\n     *      }\n     *  }\n     */\n    onShowElementsInRange: function onShowElementsInRange(e, opt) {\n      var self = this; // set animDuration to default if not defined\n\n      if (opt.animDuration === undefined) {\n        opt.animDuration = 0;\n      } // set hiddenOpacity to default if not defined\n\n\n      if (opt.hiddenOpacity === undefined) {\n        opt.hiddenOpacity = 0.3;\n      } // handle area\n\n\n      if (opt.ranges && opt.ranges.area) {\n        self.showElemByRange(opt.ranges.area, self.areas, opt.hiddenOpacity, opt.animDuration);\n      } // handle plot\n\n\n      if (opt.ranges && opt.ranges.plot) {\n        self.showElemByRange(opt.ranges.plot, self.plots, opt.hiddenOpacity, opt.animDuration);\n      } // handle link\n\n\n      if (opt.ranges && opt.ranges.link) {\n        self.showElemByRange(opt.ranges.link, self.links, opt.hiddenOpacity, opt.animDuration);\n      } // Call user callback\n\n\n      if (opt.afterShowRange) opt.afterShowRange();\n    },\n\n    /*\n     * Show some element in range\n     * @param ranges: the ranges\n     * @param elems: list of element on which to check against previous range\n     * @hiddenOpacity: the opacity when hidden\n     * @animDuration: the animation duration\n     */\n    showElemByRange: function showElemByRange(ranges, elems, hiddenOpacity, animDuration) {\n      var self = this; // Hold the final opacity value for all elements consolidated after applying each ranges\n      // This allow to set the opacity only once for each elements\n\n      var elemsFinalOpacity = {}; // set object with one valueIndex to 0 if we have directly the min/max\n\n      if (ranges.min !== undefined || ranges.max !== undefined) {\n        ranges = {\n          0: ranges\n        };\n      } // Loop through each valueIndex\n\n\n      $.each(ranges, function (valueIndex) {\n        var range = ranges[valueIndex]; // Check if user defined at least a min or max value\n\n        if (range.min === undefined && range.max === undefined) {\n          return true; // skip this iteration (each loop), goto next range\n        } // Loop through each elements\n\n\n        $.each(elems, function (id) {\n          var elemValue = elems[id].options.value; // set value with one valueIndex to 0 if not object\n\n          if (typeof elemValue !== \"object\") {\n            elemValue = [elemValue];\n          } // Check existence of this value index\n\n\n          if (elemValue[valueIndex] === undefined) {\n            return true; // skip this iteration (each loop), goto next element\n          } // Check if in range\n\n\n          if (range.min !== undefined && elemValue[valueIndex] < range.min || range.max !== undefined && elemValue[valueIndex] > range.max) {\n            // Element not in range\n            elemsFinalOpacity[id] = hiddenOpacity;\n          } else {\n            // Element in range\n            elemsFinalOpacity[id] = 1;\n          }\n        });\n      }); // Now that we looped through all ranges, we can really assign the final opacity\n\n      $.each(elemsFinalOpacity, function (id) {\n        self.setElementOpacity(elems[id], elemsFinalOpacity[id], animDuration);\n      });\n    },\n\n    /*\n     * Set element opacity\n     * Handle elem.mapElem and elem.textElem\n     * @param elem the element\n     * @param opacity the opacity to apply\n     * @param animDuration the animation duration to use\n     */\n    setElementOpacity: function setElementOpacity(elem, opacity, animDuration) {\n      var self = this; // Ensure no animation is running\n      //elem.mapElem.stop();\n      //if (elem.textElem) elem.textElem.stop();\n      // If final opacity is not null, ensure element is shown before proceeding\n\n      if (opacity > 0) {\n        elem.mapElem.show();\n        if (elem.textElem) elem.textElem.show();\n      }\n\n      self.animate(elem.mapElem, {\n        \"opacity\": opacity\n      }, animDuration, function () {\n        // If final attribute is 0, hide\n        if (opacity === 0) elem.mapElem.hide();\n      });\n      self.animate(elem.textElem, {\n        \"opacity\": opacity\n      }, animDuration, function () {\n        // If final attribute is 0, hide\n        if (opacity === 0) elem.textElem.hide();\n      });\n    },\n\n    /*\n     * Update the current map\n     *\n     * Refresh attributes and tooltips for areas and plots\n     * @param opt option for the refresh :\n     *  opt.mapOptions: options to update for plots and areas\n     *  opt.replaceOptions: whether mapsOptions should entirely replace current map options, or just extend it\n     *  opt.opt.newPlots new plots to add to the map\n     *  opt.newLinks new links to add to the map\n     *  opt.deletePlotKeys plots to delete from the map (array, or \"all\" to remove all plots)\n     *  opt.deleteLinkKeys links to remove from the map (array, or \"all\" to remove all links)\n     *  opt.setLegendElemsState the state of legend elements to be set : show (default) or hide\n     *  opt.animDuration animation duration in ms (default = 0)\n     *  opt.afterUpdate hook that allows to add custom processing on the map\n     */\n    onUpdateEvent: function onUpdateEvent(e, opt) {\n      var self = this; // Abort if opt is undefined\n\n      if (typeof opt !== \"object\") return;\n      var i = 0;\n      var animDuration = opt.animDuration ? opt.animDuration : 0; // This function remove an element using animation (or not, depending on animDuration)\n      // Used for deletePlotKeys and deleteLinkKeys\n\n      var fnRemoveElement = function fnRemoveElement(elem) {\n        self.animate(elem.mapElem, {\n          \"opacity\": 0\n        }, animDuration, function () {\n          elem.mapElem.remove();\n        });\n        self.animate(elem.textElem, {\n          \"opacity\": 0\n        }, animDuration, function () {\n          elem.textElem.remove();\n        });\n      }; // This function show an element using animation\n      // Used for newPlots and newLinks\n\n\n      var fnShowElement = function fnShowElement(elem) {\n        // Starts with hidden elements\n        elem.mapElem.attr({\n          opacity: 0\n        });\n        if (elem.textElem) elem.textElem.attr({\n          opacity: 0\n        }); // Set final element opacity\n\n        self.setElementOpacity(elem, elem.mapElem.originalAttrs.opacity !== undefined ? elem.mapElem.originalAttrs.opacity : 1, animDuration);\n      };\n\n      if (typeof opt.mapOptions === \"object\") {\n        if (opt.replaceOptions === true) self.options = self.extendDefaultOptions(opt.mapOptions);else $.extend(true, self.options, opt.mapOptions); // IF we update areas, plots or legend, then reset all legend state to \"show\"\n\n        if (opt.mapOptions.areas !== undefined || opt.mapOptions.plots !== undefined || opt.mapOptions.legend !== undefined) {\n          $(\"[data-type='legend-elem']\", self.$container).each(function (id, elem) {\n            if ($(elem).attr('data-hidden') === \"1\") {\n              // Toggle state of element by clicking\n              $(elem).trigger(\"click\", {\n                hideOtherElems: false,\n                animDuration: animDuration\n              });\n            }\n          });\n        }\n      } // Delete plots by name if deletePlotKeys is array\n\n\n      if (typeof opt.deletePlotKeys === \"object\") {\n        for (; i < opt.deletePlotKeys.length; i++) {\n          if (self.plots[opt.deletePlotKeys[i]] !== undefined) {\n            fnRemoveElement(self.plots[opt.deletePlotKeys[i]]);\n            delete self.plots[opt.deletePlotKeys[i]];\n          }\n        } // Delete ALL plots if deletePlotKeys is set to \"all\"\n\n      } else if (opt.deletePlotKeys === \"all\") {\n        $.each(self.plots, function (id, elem) {\n          fnRemoveElement(elem);\n        }); // Empty plots object\n\n        self.plots = {};\n      } // Delete links by name if deleteLinkKeys is array\n\n\n      if (typeof opt.deleteLinkKeys === \"object\") {\n        for (i = 0; i < opt.deleteLinkKeys.length; i++) {\n          if (self.links[opt.deleteLinkKeys[i]] !== undefined) {\n            fnRemoveElement(self.links[opt.deleteLinkKeys[i]]);\n            delete self.links[opt.deleteLinkKeys[i]];\n          }\n        } // Delete ALL links if deleteLinkKeys is set to \"all\"\n\n      } else if (opt.deleteLinkKeys === \"all\") {\n        $.each(self.links, function (id, elem) {\n          fnRemoveElement(elem);\n        }); // Empty links object\n\n        self.links = {};\n      } // New plots\n\n\n      if (typeof opt.newPlots === \"object\") {\n        $.each(opt.newPlots, function (id) {\n          if (self.plots[id] === undefined) {\n            self.options.plots[id] = opt.newPlots[id];\n            self.plots[id] = self.drawPlot(id);\n\n            if (animDuration > 0) {\n              fnShowElement(self.plots[id]);\n            }\n          }\n        });\n      } // New links\n\n\n      if (typeof opt.newLinks === \"object\") {\n        var newLinks = self.drawLinksCollection(opt.newLinks);\n        $.extend(self.links, newLinks);\n        $.extend(self.options.links, opt.newLinks);\n\n        if (animDuration > 0) {\n          $.each(newLinks, function (id) {\n            fnShowElement(newLinks[id]);\n          });\n        }\n      } // Update areas attributes and tooltips\n\n\n      $.each(self.areas, function (id) {\n        // Avoid updating unchanged elements\n        if (typeof opt.mapOptions === \"object\" && (typeof opt.mapOptions.map === \"object\" && typeof opt.mapOptions.map.defaultArea === \"object\" || typeof opt.mapOptions.areas === \"object\" && typeof opt.mapOptions.areas[id] === \"object\" || typeof opt.mapOptions.legend === \"object\" && typeof opt.mapOptions.legend.area === \"object\") || opt.replaceOptions === true) {\n          self.areas[id].options = self.getElemOptions(self.options.map.defaultArea, self.options.areas[id] ? self.options.areas[id] : {}, self.options.legend.area);\n          self.updateElem(self.areas[id], animDuration);\n        }\n      }); // Update plots attributes and tooltips\n\n      $.each(self.plots, function (id) {\n        // Avoid updating unchanged elements\n        if (typeof opt.mapOptions === \"object\" && (typeof opt.mapOptions.map === \"object\" && typeof opt.mapOptions.map.defaultPlot === \"object\" || typeof opt.mapOptions.plots === \"object\" && typeof opt.mapOptions.plots[id] === \"object\" || typeof opt.mapOptions.legend === \"object\" && typeof opt.mapOptions.legend.plot === \"object\") || opt.replaceOptions === true) {\n          self.plots[id].options = self.getElemOptions(self.options.map.defaultPlot, self.options.plots[id] ? self.options.plots[id] : {}, self.options.legend.plot);\n          self.setPlotCoords(self.plots[id]);\n          self.setPlotAttributes(self.plots[id]);\n          self.updateElem(self.plots[id], animDuration);\n        }\n      }); // Update links attributes and tooltips\n\n      $.each(self.links, function (id) {\n        // Avoid updating unchanged elements\n        if (typeof opt.mapOptions === \"object\" && (typeof opt.mapOptions.map === \"object\" && typeof opt.mapOptions.map.defaultLink === \"object\" || typeof opt.mapOptions.links === \"object\" && typeof opt.mapOptions.links[id] === \"object\") || opt.replaceOptions === true) {\n          self.links[id].options = self.getElemOptions(self.options.map.defaultLink, self.options.links[id] ? self.options.links[id] : {}, {});\n          self.updateElem(self.links[id], animDuration);\n        }\n      }); // Update legends\n\n      if (opt.mapOptions && (typeof opt.mapOptions.legend === \"object\" || typeof opt.mapOptions.map === \"object\" && typeof opt.mapOptions.map.defaultArea === \"object\" || typeof opt.mapOptions.map === \"object\" && typeof opt.mapOptions.map.defaultPlot === \"object\")) {\n        // Show all elements on the map before updating the legends\n        $(\"[data-type='legend-elem']\", self.$container).each(function (id, elem) {\n          if ($(elem).attr('data-hidden') === \"1\") {\n            $(elem).trigger(\"click\", {\n              hideOtherElems: false,\n              animDuration: animDuration\n            });\n          }\n        });\n        self.createLegends(\"area\", self.areas, 1);\n\n        if (self.options.map.width) {\n          self.createLegends(\"plot\", self.plots, self.options.map.width / self.mapConf.width);\n        } else {\n          self.createLegends(\"plot\", self.plots, self.$map.width() / self.mapConf.width);\n        }\n      } // Hide/Show all elements based on showlegendElems\n      //      Toggle (i.e. click) only if:\n      //          - slice legend is shown AND we want to hide\n      //          - slice legend is hidden AND we want to show\n\n\n      if (typeof opt.setLegendElemsState === \"object\") {\n        // setLegendElemsState is an object listing the legend we want to hide/show\n        $.each(opt.setLegendElemsState, function (legendCSSClass, action) {\n          // Search for the legend\n          var $legend = self.$container.find(\".\" + legendCSSClass)[0];\n\n          if ($legend !== undefined) {\n            // Select all elem inside this legend\n            $(\"[data-type='legend-elem']\", $legend).each(function (id, elem) {\n              if ($(elem).attr('data-hidden') === \"0\" && action === \"hide\" || $(elem).attr('data-hidden') === \"1\" && action === \"show\") {\n                // Toggle state of element by clicking\n                $(elem).trigger(\"click\", {\n                  hideOtherElems: false,\n                  animDuration: animDuration\n                });\n              }\n            });\n          }\n        });\n      } else {\n        // setLegendElemsState is a string, or is undefined\n        // Default : \"show\"\n        var action = opt.setLegendElemsState === \"hide\" ? \"hide\" : \"show\";\n        $(\"[data-type='legend-elem']\", self.$container).each(function (id, elem) {\n          if ($(elem).attr('data-hidden') === \"0\" && action === \"hide\" || $(elem).attr('data-hidden') === \"1\" && action === \"show\") {\n            // Toggle state of element by clicking\n            $(elem).trigger(\"click\", {\n              hideOtherElems: false,\n              animDuration: animDuration\n            });\n          }\n        });\n      } // Always rebind custom events on update\n\n\n      self.initDelegatedCustomEvents();\n      if (opt.afterUpdate) opt.afterUpdate(self.$container, self.paper, self.areas, self.plots, self.options, self.links);\n    },\n\n    /*\n     * Set plot coordinates\n     * @param plot object plot element\n     */\n    setPlotCoords: function setPlotCoords(plot) {\n      var self = this;\n\n      if (plot.options.x !== undefined && plot.options.y !== undefined) {\n        plot.coords = {\n          x: plot.options.x,\n          y: plot.options.y\n        };\n      } else if (plot.options.plotsOn !== undefined && self.areas[plot.options.plotsOn] !== undefined) {\n        var areaBBox = self.areas[plot.options.plotsOn].mapElem.getBBox();\n        plot.coords = {\n          x: areaBBox.cx,\n          y: areaBBox.cy\n        };\n      } else {\n        plot.coords = self.mapConf.getCoords(plot.options.latitude, plot.options.longitude);\n      }\n    },\n\n    /*\n     * Set plot size attributes according to its type\n     * Note: for SVG, plot.mapElem needs to exists beforehand\n     * @param plot object plot element\n     */\n    setPlotAttributes: function setPlotAttributes(plot) {\n      if (plot.options.type === \"square\") {\n        plot.options.attrs.width = plot.options.size;\n        plot.options.attrs.height = plot.options.size;\n        plot.options.attrs.x = plot.coords.x - plot.options.size / 2;\n        plot.options.attrs.y = plot.coords.y - plot.options.size / 2;\n      } else if (plot.options.type === \"image\") {\n        plot.options.attrs.src = plot.options.url;\n        plot.options.attrs.width = plot.options.width;\n        plot.options.attrs.height = plot.options.height;\n        plot.options.attrs.x = plot.coords.x - plot.options.width / 2;\n        plot.options.attrs.y = plot.coords.y - plot.options.height / 2;\n      } else if (plot.options.type === \"svg\") {\n        plot.options.attrs.path = plot.options.path; // Init transform string\n\n        if (plot.options.attrs.transform === undefined) {\n          plot.options.attrs.transform = \"\";\n        } // Retrieve original boundary box if not defined\n\n\n        if (plot.mapElem.originalBBox === undefined) {\n          plot.mapElem.originalBBox = plot.mapElem.getBBox();\n        } // The base transform will resize the SVG path to the one specified by width/height\n        // and also move the path to the actual coordinates\n\n\n        plot.mapElem.baseTransform = \"m\" + plot.options.width / plot.mapElem.originalBBox.width + \",0,0,\" + plot.options.height / plot.mapElem.originalBBox.height + \",\" + (plot.coords.x - plot.options.width / 2) + \",\" + (plot.coords.y - plot.options.height / 2);\n        plot.options.attrs.transform = plot.mapElem.baseTransform + plot.options.attrs.transform;\n      } else {\n        // Default : circle\n        plot.options.attrs.x = plot.coords.x;\n        plot.options.attrs.y = plot.coords.y;\n        plot.options.attrs.r = plot.options.size / 2;\n      }\n    },\n\n    /*\n     * Draw all links between plots on the paper\n     */\n    drawLinksCollection: function drawLinksCollection(linksCollection) {\n      var self = this;\n      var p1 = {};\n      var p2 = {};\n      var coordsP1 = {};\n      var coordsP2 = {};\n      var links = {};\n      $.each(linksCollection, function (id) {\n        var elemOptions = self.getElemOptions(self.options.map.defaultLink, linksCollection[id], {});\n\n        if (typeof linksCollection[id].between[0] === 'string') {\n          p1 = self.options.plots[linksCollection[id].between[0]];\n        } else {\n          p1 = linksCollection[id].between[0];\n        }\n\n        if (typeof linksCollection[id].between[1] === 'string') {\n          p2 = self.options.plots[linksCollection[id].between[1]];\n        } else {\n          p2 = linksCollection[id].between[1];\n        }\n\n        if (p1.plotsOn !== undefined && self.areas[p1.plotsOn] !== undefined) {\n          var p1BBox = self.areas[p1.plotsOn].mapElem.getBBox();\n          coordsP1 = {\n            x: p1BBox.cx,\n            y: p1BBox.cy\n          };\n        } else if (p1.latitude !== undefined && p1.longitude !== undefined) {\n          coordsP1 = self.mapConf.getCoords(p1.latitude, p1.longitude);\n        } else {\n          coordsP1.x = p1.x;\n          coordsP1.y = p1.y;\n        }\n\n        if (p2.plotsOn !== undefined && self.areas[p2.plotsOn] !== undefined) {\n          var p2BBox = self.areas[p2.plotsOn].mapElem.getBBox();\n          coordsP2 = {\n            x: p2BBox.cx,\n            y: p2BBox.cy\n          };\n        } else if (p2.latitude !== undefined && p2.longitude !== undefined) {\n          coordsP2 = self.mapConf.getCoords(p2.latitude, p2.longitude);\n        } else {\n          coordsP2.x = p2.x;\n          coordsP2.y = p2.y;\n        }\n\n        links[id] = self.drawLink(id, coordsP1.x, coordsP1.y, coordsP2.x, coordsP2.y, elemOptions);\n      });\n      return links;\n    },\n\n    /*\n     * Draw a curved link between two couples of coordinates a(xa,ya) and b(xb, yb) on the paper\n     */\n    drawLink: function drawLink(id, xa, ya, xb, yb, elemOptions) {\n      var self = this;\n      var link = {\n        options: elemOptions\n      }; // Compute the \"curveto\" SVG point, d(x,y)\n      // c(xc, yc) is the center of (xa,ya) and (xb, yb)\n\n      var xc = (xa + xb) / 2;\n      var yc = (ya + yb) / 2; // Equation for (cd) : y = acd * x + bcd (d is the cure point)\n\n      var acd = -1 / ((yb - ya) / (xb - xa));\n      var bcd = yc - acd * xc; // dist(c,d) = dist(a,b) (=abDist)\n\n      var abDist = Math.sqrt((xb - xa) * (xb - xa) + (yb - ya) * (yb - ya)); // Solution for equation dist(cd) = sqrt((xd - xc)¬≤ + (yd - yc)¬≤)\n      // dist(c,d)¬≤ = (xd - xc)¬≤ + (yd - yc)¬≤\n      // We assume that dist(c,d) = dist(a,b)\n      // so : (xd - xc)¬≤ + (yd - yc)¬≤ - dist(a,b)¬≤ = 0\n      // With the factor : (xd - xc)¬≤ + (yd - yc)¬≤ - (factor*dist(a,b))¬≤ = 0\n      // (xd - xc)¬≤ + (acd*xd + bcd - yc)¬≤ - (factor*dist(a,b))¬≤ = 0\n\n      var a = 1 + acd * acd;\n      var b = -2 * xc + 2 * acd * bcd - 2 * acd * yc;\n      var c = xc * xc + bcd * bcd - bcd * yc - yc * bcd + yc * yc - elemOptions.factor * abDist * (elemOptions.factor * abDist);\n      var delta = b * b - 4 * a * c;\n      var x = 0;\n      var y = 0; // There are two solutions, we choose one or the other depending on the sign of the factor\n\n      if (elemOptions.factor > 0) {\n        x = (-b + Math.sqrt(delta)) / (2 * a);\n        y = acd * x + bcd;\n      } else {\n        x = (-b - Math.sqrt(delta)) / (2 * a);\n        y = acd * x + bcd;\n      }\n\n      link.mapElem = self.paper.path(\"m \" + xa + \",\" + ya + \" C \" + x + \",\" + y + \" \" + xb + \",\" + yb + \" \" + xb + \",\" + yb + \"\");\n      self.initElem(id, 'link', link);\n      return link;\n    },\n\n    /*\n     * Check wether newAttrs object bring modifications to originalAttrs object\n     */\n    isAttrsChanged: function isAttrsChanged(originalAttrs, newAttrs) {\n      for (var key in newAttrs) {\n        if (newAttrs.hasOwnProperty(key) && typeof originalAttrs[key] === 'undefined' || newAttrs[key] !== originalAttrs[key]) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /*\n     * Update the element \"elem\" on the map with the new options\n     */\n    updateElem: function updateElem(elem, animDuration) {\n      var self = this;\n      var mapElemBBox;\n      var plotOffsetX;\n      var plotOffsetY;\n\n      if (elem.options.toFront === true) {\n        elem.mapElem.toFront();\n      } // Set the cursor attribute related to the HTML link\n\n\n      if (elem.options.href !== undefined) {\n        elem.options.attrs.cursor = \"pointer\";\n        if (elem.options.text) elem.options.text.attrs.cursor = \"pointer\";\n      } else {\n        // No HTML links, check if a cursor was defined to pointer\n        if (elem.mapElem.attrs.cursor === 'pointer') {\n          elem.options.attrs.cursor = \"auto\";\n          if (elem.options.text) elem.options.text.attrs.cursor = \"auto\";\n        }\n      } // Update the label\n\n\n      if (elem.textElem) {\n        // Update text attr\n        elem.options.text.attrs.text = elem.options.text.content; // Get mapElem size, and apply an offset to handle future width/height change\n\n        mapElemBBox = elem.mapElem.getBBox();\n\n        if (elem.options.size || elem.options.width && elem.options.height) {\n          if (elem.options.type === \"image\" || elem.options.type === \"svg\") {\n            plotOffsetX = (elem.options.width - mapElemBBox.width) / 2;\n            plotOffsetY = (elem.options.height - mapElemBBox.height) / 2;\n          } else {\n            plotOffsetX = (elem.options.size - mapElemBBox.width) / 2;\n            plotOffsetY = (elem.options.size - mapElemBBox.height) / 2;\n          }\n\n          mapElemBBox.x -= plotOffsetX;\n          mapElemBBox.x2 += plotOffsetX;\n          mapElemBBox.y -= plotOffsetY;\n          mapElemBBox.y2 += plotOffsetY;\n        } // Update position attr\n\n\n        var textPosition = self.getTextPosition(mapElemBBox, elem.options.text.position, elem.options.text.margin);\n        elem.options.text.attrs.x = textPosition.x;\n        elem.options.text.attrs.y = textPosition.y;\n        elem.options.text.attrs['text-anchor'] = textPosition.textAnchor; // Update text element attrs and attrsHover\n\n        self.setHoverOptions(elem.textElem, elem.options.text.attrs, elem.options.text.attrsHover);\n\n        if (self.isAttrsChanged(elem.textElem.attrs, elem.options.text.attrs)) {\n          self.animate(elem.textElem, elem.options.text.attrs, animDuration);\n        }\n      } // Update elements attrs and attrsHover\n\n\n      self.setHoverOptions(elem.mapElem, elem.options.attrs, elem.options.attrsHover);\n\n      if (self.isAttrsChanged(elem.mapElem.attrs, elem.options.attrs)) {\n        self.animate(elem.mapElem, elem.options.attrs, animDuration);\n      } // Update the cssClass\n\n\n      if (elem.options.cssClass !== undefined) {\n        $(elem.mapElem.node).removeClass().addClass(elem.options.cssClass);\n      }\n    },\n\n    /*\n     * Draw the plot\n     */\n    drawPlot: function drawPlot(id) {\n      var self = this;\n      var plot = {}; // Get plot options and store it\n\n      plot.options = self.getElemOptions(self.options.map.defaultPlot, self.options.plots[id] ? self.options.plots[id] : {}, self.options.legend.plot); // Set plot coords\n\n      self.setPlotCoords(plot); // Draw SVG before setPlotAttributes()\n\n      if (plot.options.type === \"svg\") {\n        plot.mapElem = self.paper.path(plot.options.path);\n      } // Set plot size attrs\n\n\n      self.setPlotAttributes(plot); // Draw other types of plots\n\n      if (plot.options.type === \"square\") {\n        plot.mapElem = self.paper.rect(plot.options.attrs.x, plot.options.attrs.y, plot.options.attrs.width, plot.options.attrs.height);\n      } else if (plot.options.type === \"image\") {\n        plot.mapElem = self.paper.image(plot.options.attrs.src, plot.options.attrs.x, plot.options.attrs.y, plot.options.attrs.width, plot.options.attrs.height);\n      } else if (plot.options.type === \"svg\") {// Nothing to do\n      } else {\n        // Default = circle\n        plot.mapElem = self.paper.circle(plot.options.attrs.x, plot.options.attrs.y, plot.options.attrs.r);\n      }\n\n      self.initElem(id, 'plot', plot);\n      return plot;\n    },\n\n    /*\n     * Set user defined handlers for events on areas and plots\n     * @param id the id of the element\n     * @param type the type of the element (area, plot, link)\n     * @param elem the element object {mapElem, textElem, options, ...}\n     */\n    setEventHandlers: function setEventHandlers(id, type, elem) {\n      var self = this;\n      $.each(elem.options.eventHandlers, function (event) {\n        if (self.customEventHandlers[event] === undefined) self.customEventHandlers[event] = {};\n        if (self.customEventHandlers[event][type] === undefined) self.customEventHandlers[event][type] = {};\n        self.customEventHandlers[event][type][id] = elem;\n      });\n    },\n\n    /*\n     * Draw a legend for areas and / or plots\n     * @param legendOptions options for the legend to draw\n     * @param legendType the type of the legend : \"area\" or \"plot\"\n     * @param elems collection of plots or areas on the maps\n     * @param legendIndex index of the legend in the conf array\n     */\n    drawLegend: function drawLegend(legendOptions, legendType, elems, scale, legendIndex) {\n      var self = this;\n      var $legend = {};\n      var legendPaper = {};\n      var width = 0;\n      var height = 0;\n      var title = null;\n      var titleBBox = null;\n      var legendElems = {};\n      var i = 0;\n      var x = 0;\n      var y = 0;\n      var yCenter = 0;\n      var sliceOptions = [];\n      $legend = $(\".\" + legendOptions.cssClass, self.$container); // Save content for later\n\n      var initialHTMLContent = $legend.html();\n      $legend.empty();\n      legendPaper = new Raphael($legend.get(0)); // Set some data to object\n\n      $(legendPaper.canvas).attr({\n        \"data-legend-type\": legendType,\n        \"data-legend-id\": legendIndex\n      });\n      height = width = 0; // Set the title of the legend\n\n      if (legendOptions.title && legendOptions.title !== \"\") {\n        title = legendPaper.text(legendOptions.marginLeftTitle, 0, legendOptions.title).attr(legendOptions.titleAttrs);\n        titleBBox = title.getBBox();\n        title.attr({\n          y: 0.5 * titleBBox.height\n        });\n        width = legendOptions.marginLeftTitle + titleBBox.width;\n        height += legendOptions.marginBottomTitle + titleBBox.height;\n      } // Calculate attrs (and width, height and r (radius)) for legend elements, and yCenter for horizontal legends\n\n\n      for (i = 0; i < legendOptions.slices.length; ++i) {\n        var yCenterCurrent = 0;\n        sliceOptions[i] = $.extend(true, {}, legendType === \"plot\" ? self.options.map.defaultPlot : self.options.map.defaultArea, legendOptions.slices[i]);\n\n        if (legendOptions.slices[i].legendSpecificAttrs === undefined) {\n          legendOptions.slices[i].legendSpecificAttrs = {};\n        }\n\n        $.extend(true, sliceOptions[i].attrs, legendOptions.slices[i].legendSpecificAttrs);\n\n        if (legendType === \"area\") {\n          if (sliceOptions[i].attrs.width === undefined) sliceOptions[i].attrs.width = 30;\n          if (sliceOptions[i].attrs.height === undefined) sliceOptions[i].attrs.height = 20;\n        } else if (sliceOptions[i].type === \"square\") {\n          if (sliceOptions[i].attrs.width === undefined) sliceOptions[i].attrs.width = sliceOptions[i].size;\n          if (sliceOptions[i].attrs.height === undefined) sliceOptions[i].attrs.height = sliceOptions[i].size;\n        } else if (sliceOptions[i].type === \"image\" || sliceOptions[i].type === \"svg\") {\n          if (sliceOptions[i].attrs.width === undefined) sliceOptions[i].attrs.width = sliceOptions[i].width;\n          if (sliceOptions[i].attrs.height === undefined) sliceOptions[i].attrs.height = sliceOptions[i].height;\n        } else {\n          if (sliceOptions[i].attrs.r === undefined) sliceOptions[i].attrs.r = sliceOptions[i].size / 2;\n        } // Compute yCenter for this legend slice\n\n\n        yCenterCurrent = legendOptions.marginBottomTitle; // Add title height if it exists\n\n        if (title) {\n          yCenterCurrent += titleBBox.height;\n        }\n\n        if (legendType === \"plot\" && (sliceOptions[i].type === undefined || sliceOptions[i].type === \"circle\")) {\n          yCenterCurrent += scale * sliceOptions[i].attrs.r;\n        } else {\n          yCenterCurrent += scale * sliceOptions[i].attrs.height / 2;\n        } // Update yCenter if current larger\n\n\n        yCenter = Math.max(yCenter, yCenterCurrent);\n      }\n\n      if (legendOptions.mode === \"horizontal\") {\n        width = legendOptions.marginLeft;\n      } // Draw legend elements (circle, square or image in vertical or horizontal mode)\n\n\n      for (i = 0; i < sliceOptions.length; ++i) {\n        var legendElem = {};\n        var legendElemBBox = {};\n        var legendLabel = {};\n\n        if (sliceOptions[i].display === undefined || sliceOptions[i].display === true) {\n          if (legendType === \"area\") {\n            if (legendOptions.mode === \"horizontal\") {\n              x = width + legendOptions.marginLeft;\n              y = yCenter - 0.5 * scale * sliceOptions[i].attrs.height;\n            } else {\n              x = legendOptions.marginLeft;\n              y = height;\n            }\n\n            legendElem = legendPaper.rect(x, y, scale * sliceOptions[i].attrs.width, scale * sliceOptions[i].attrs.height);\n          } else if (sliceOptions[i].type === \"square\") {\n            if (legendOptions.mode === \"horizontal\") {\n              x = width + legendOptions.marginLeft;\n              y = yCenter - 0.5 * scale * sliceOptions[i].attrs.height;\n            } else {\n              x = legendOptions.marginLeft;\n              y = height;\n            }\n\n            legendElem = legendPaper.rect(x, y, scale * sliceOptions[i].attrs.width, scale * sliceOptions[i].attrs.height);\n          } else if (sliceOptions[i].type === \"image\" || sliceOptions[i].type === \"svg\") {\n            if (legendOptions.mode === \"horizontal\") {\n              x = width + legendOptions.marginLeft;\n              y = yCenter - 0.5 * scale * sliceOptions[i].attrs.height;\n            } else {\n              x = legendOptions.marginLeft;\n              y = height;\n            }\n\n            if (sliceOptions[i].type === \"image\") {\n              legendElem = legendPaper.image(sliceOptions[i].url, x, y, scale * sliceOptions[i].attrs.width, scale * sliceOptions[i].attrs.height);\n            } else {\n              legendElem = legendPaper.path(sliceOptions[i].path);\n\n              if (sliceOptions[i].attrs.transform === undefined) {\n                sliceOptions[i].attrs.transform = \"\";\n              }\n\n              legendElemBBox = legendElem.getBBox();\n              sliceOptions[i].attrs.transform = \"m\" + scale * sliceOptions[i].width / legendElemBBox.width + \",0,0,\" + scale * sliceOptions[i].height / legendElemBBox.height + \",\" + x + \",\" + y + sliceOptions[i].attrs.transform;\n            }\n          } else {\n            if (legendOptions.mode === \"horizontal\") {\n              x = width + legendOptions.marginLeft + scale * sliceOptions[i].attrs.r;\n              y = yCenter;\n            } else {\n              x = legendOptions.marginLeft + scale * sliceOptions[i].attrs.r;\n              y = height + scale * sliceOptions[i].attrs.r;\n            }\n\n            legendElem = legendPaper.circle(x, y, scale * sliceOptions[i].attrs.r);\n          } // Set attrs to the element drawn above\n\n\n          delete sliceOptions[i].attrs.width;\n          delete sliceOptions[i].attrs.height;\n          delete sliceOptions[i].attrs.r;\n          legendElem.attr(sliceOptions[i].attrs);\n          legendElemBBox = legendElem.getBBox(); // Draw the label associated with the element\n\n          if (legendOptions.mode === \"horizontal\") {\n            x = width + legendOptions.marginLeft + legendElemBBox.width + legendOptions.marginLeftLabel;\n            y = yCenter;\n          } else {\n            x = legendOptions.marginLeft + legendElemBBox.width + legendOptions.marginLeftLabel;\n            y = height + legendElemBBox.height / 2;\n          }\n\n          legendLabel = legendPaper.text(x, y, sliceOptions[i].label).attr(legendOptions.labelAttrs); // Update the width and height for the paper\n\n          if (legendOptions.mode === \"horizontal\") {\n            var currentHeight = legendOptions.marginBottom + legendElemBBox.height;\n            width += legendOptions.marginLeft + legendElemBBox.width + legendOptions.marginLeftLabel + legendLabel.getBBox().width;\n\n            if (sliceOptions[i].type !== \"image\" && legendType !== \"area\") {\n              currentHeight += legendOptions.marginBottomTitle;\n            } // Add title height if it exists\n\n\n            if (title) {\n              currentHeight += titleBBox.height;\n            }\n\n            height = Math.max(height, currentHeight);\n          } else {\n            width = Math.max(width, legendOptions.marginLeft + legendElemBBox.width + legendOptions.marginLeftLabel + legendLabel.getBBox().width);\n            height += legendOptions.marginBottom + legendElemBBox.height;\n          } // Set some data to elements\n\n\n          $(legendElem.node).attr({\n            \"data-legend-id\": legendIndex,\n            \"data-legend-type\": legendType,\n            \"data-type\": \"legend-elem\",\n            \"data-id\": i,\n            \"data-hidden\": 0\n          });\n          $(legendLabel.node).attr({\n            \"data-legend-id\": legendIndex,\n            \"data-legend-type\": legendType,\n            \"data-type\": \"legend-label\",\n            \"data-id\": i,\n            \"data-hidden\": 0\n          }); // Set array content\n          // We use similar names like map/plots/links\n\n          legendElems[i] = {\n            mapElem: legendElem,\n            textElem: legendLabel\n          }; // Hide map elements when the user clicks on a legend item\n\n          if (legendOptions.hideElemsOnClick.enabled) {\n            // Hide/show elements when user clicks on a legend element\n            legendLabel.attr({\n              cursor: \"pointer\"\n            });\n            legendElem.attr({\n              cursor: \"pointer\"\n            });\n            self.setHoverOptions(legendElem, sliceOptions[i].attrs, sliceOptions[i].attrs);\n            self.setHoverOptions(legendLabel, legendOptions.labelAttrs, legendOptions.labelAttrsHover);\n\n            if (sliceOptions[i].clicked !== undefined && sliceOptions[i].clicked === true) {\n              self.handleClickOnLegendElem(legendElems[i], i, legendIndex, legendType, {\n                hideOtherElems: false\n              });\n            }\n          }\n        }\n      } // VMLWidth option allows you to set static width for the legend\n      // only for VML render because text.getBBox() returns wrong values on IE6/7\n\n\n      if (Raphael.type !== \"SVG\" && legendOptions.VMLWidth) width = legendOptions.VMLWidth;\n      legendPaper.setSize(width, height);\n      return {\n        container: $legend,\n        initialHTMLContent: initialHTMLContent,\n        elems: legendElems\n      };\n    },\n\n    /*\n     * Allow to hide elements of the map when the user clicks on a related legend item\n     * @param elem legend element\n     * @param id legend element ID\n     * @param legendIndex corresponding legend index\n     * @param legendType corresponding legend type (area or plot)\n     * @param opts object additionnal options\n     *          hideOtherElems boolean, if other elems shall be hidden\n     *          animDuration duration of animation\n     */\n    handleClickOnLegendElem: function handleClickOnLegendElem(elem, id, legendIndex, legendType, opts) {\n      var self = this;\n      var legendOptions;\n      opts = opts || {};\n\n      if (!$.isArray(self.options.legend[legendType])) {\n        legendOptions = self.options.legend[legendType];\n      } else {\n        legendOptions = self.options.legend[legendType][legendIndex];\n      }\n\n      var legendElem = elem.mapElem;\n      var legendLabel = elem.textElem;\n      var $legendElem = $(legendElem.node);\n      var $legendLabel = $(legendLabel.node);\n      var sliceOptions = legendOptions.slices[id];\n      var mapElems = legendType === 'area' ? self.areas : self.plots; // Check animDuration: if not set, this is a regular click, use the value specified in options\n\n      var animDuration = opts.animDuration !== undefined ? opts.animDuration : legendOptions.hideElemsOnClick.animDuration;\n      var hidden = $legendElem.attr('data-hidden');\n      var hiddenNewAttr = hidden === '0' ? {\n        \"data-hidden\": '1'\n      } : {\n        \"data-hidden\": '0'\n      };\n\n      if (hidden === '0') {\n        self.animate(legendLabel, {\n          \"opacity\": 0.5\n        }, animDuration);\n      } else {\n        self.animate(legendLabel, {\n          \"opacity\": 1\n        }, animDuration);\n      }\n\n      $.each(mapElems, function (y) {\n        var elemValue; // Retreive stored data of element\n        //      'hidden-by' contains the list of legendIndex that is hiding this element\n\n        var hiddenBy = mapElems[y].mapElem.data('hidden-by'); // Set to empty object if undefined\n\n        if (hiddenBy === undefined) hiddenBy = {};\n\n        if ($.isArray(mapElems[y].options.value)) {\n          elemValue = mapElems[y].options.value[legendIndex];\n        } else {\n          elemValue = mapElems[y].options.value;\n        } // Hide elements whose value matches with the slice of the clicked legend item\n\n\n        if (self.getLegendSlice(elemValue, legendOptions) === sliceOptions) {\n          if (hidden === '0') {\n            // we want to hide this element\n            hiddenBy[legendIndex] = true; // add legendIndex to the data object for later use\n\n            self.setElementOpacity(mapElems[y], legendOptions.hideElemsOnClick.opacity, animDuration);\n          } else {\n            // We want to show this element\n            delete hiddenBy[legendIndex]; // Remove this legendIndex from object\n            // Check if another legendIndex is defined\n            // We will show this element only if no legend is no longer hiding it\n\n            if ($.isEmptyObject(hiddenBy)) {\n              self.setElementOpacity(mapElems[y], mapElems[y].mapElem.originalAttrs.opacity !== undefined ? mapElems[y].mapElem.originalAttrs.opacity : 1, animDuration);\n            }\n          } // Update elem data with new values\n\n\n          mapElems[y].mapElem.data('hidden-by', hiddenBy);\n        }\n      });\n      $legendElem.attr(hiddenNewAttr);\n      $legendLabel.attr(hiddenNewAttr);\n\n      if ((opts.hideOtherElems === undefined || opts.hideOtherElems === true) && legendOptions.exclusive === true) {\n        $(\"[data-type='legend-elem'][data-hidden=0]\", self.$container).each(function () {\n          var $elem = $(this);\n\n          if ($elem.attr('data-id') !== id) {\n            $elem.trigger(\"click\", {\n              hideOtherElems: false\n            });\n          }\n        });\n      }\n    },\n\n    /*\n     * Create all legends for a specified type (area or plot)\n     * @param legendType the type of the legend : \"area\" or \"plot\"\n     * @param elems collection of plots or areas displayed on the map\n     * @param scale scale ratio of the map\n     */\n    createLegends: function createLegends(legendType, elems, scale) {\n      var self = this;\n      var legendsOptions = self.options.legend[legendType];\n\n      if (!$.isArray(self.options.legend[legendType])) {\n        legendsOptions = [self.options.legend[legendType]];\n      }\n\n      self.legends[legendType] = {};\n\n      for (var j = 0; j < legendsOptions.length; ++j) {\n        if (legendsOptions[j].display === true && $.isArray(legendsOptions[j].slices) && legendsOptions[j].slices.length > 0 && legendsOptions[j].cssClass !== \"\" && $(\".\" + legendsOptions[j].cssClass, self.$container).length !== 0) {\n          self.legends[legendType][j] = self.drawLegend(legendsOptions[j], legendType, elems, scale, j);\n        }\n      }\n    },\n\n    /*\n     * Set the attributes on hover and the attributes to restore for a map element\n     * @param elem the map element\n     * @param originalAttrs the original attributes to restore on mouseout event\n     * @param attrsHover the attributes to set on mouseover event\n     */\n    setHoverOptions: function setHoverOptions(elem, originalAttrs, attrsHover) {\n      // Disable transform option on hover for VML (IE<9) because of several bugs\n      if (Raphael.type !== \"SVG\") delete attrsHover.transform;\n      elem.attrsHover = attrsHover;\n      if (elem.attrsHover.transform) elem.originalAttrs = $.extend({\n        transform: \"s1\"\n      }, originalAttrs);else elem.originalAttrs = originalAttrs;\n    },\n\n    /*\n     * Set the behaviour when mouse enters element (\"mouseover\" event)\n     * It may be an area, a plot, a link or a legend element\n     * @param elem the map element\n     */\n    elemEnter: function elemEnter(elem) {\n      var self = this;\n      if (elem === undefined) return;\n      /* Handle mapElem Hover attributes */\n\n      if (elem.mapElem !== undefined) {\n        self.animate(elem.mapElem, elem.mapElem.attrsHover, elem.mapElem.attrsHover.animDuration);\n      }\n      /* Handle textElem Hover attributes */\n\n\n      if (elem.textElem !== undefined) {\n        self.animate(elem.textElem, elem.textElem.attrsHover, elem.textElem.attrsHover.animDuration);\n      }\n      /* Handle tooltip init */\n\n\n      if (elem.options && elem.options.tooltip !== undefined) {\n        var content = ''; // Reset classes\n\n        self.$tooltip.removeClass().addClass(self.options.map.tooltip.cssClass); // Get content\n\n        if (elem.options.tooltip.content !== undefined) {\n          // if tooltip.content is function, call it. Otherwise, assign it directly.\n          if (typeof elem.options.tooltip.content === \"function\") content = elem.options.tooltip.content(elem.mapElem);else content = elem.options.tooltip.content;\n        }\n\n        if (elem.options.tooltip.cssClass !== undefined) {\n          self.$tooltip.addClass(elem.options.tooltip.cssClass);\n        }\n\n        self.$tooltip.html(content).css(\"display\", \"block\");\n      } // workaround for older version of Raphael\n\n\n      if (elem.mapElem !== undefined || elem.textElem !== undefined) {\n        if (self.paper.safari) self.paper.safari();\n      }\n    },\n\n    /*\n     * Set the behaviour when mouse moves in element (\"mousemove\" event)\n     * @param elem the map element\n     */\n    elemHover: function elemHover(elem, event) {\n      var self = this;\n      if (elem === undefined) return;\n      /* Handle tooltip position update */\n\n      if (elem.options.tooltip !== undefined) {\n        var mouseX = event.pageX;\n        var mouseY = event.pageY;\n        var offsetLeft = 10;\n        var offsetTop = 20;\n\n        if (typeof elem.options.tooltip.offset === \"object\") {\n          if (typeof elem.options.tooltip.offset.left !== \"undefined\") {\n            offsetLeft = elem.options.tooltip.offset.left;\n          }\n\n          if (typeof elem.options.tooltip.offset.top !== \"undefined\") {\n            offsetTop = elem.options.tooltip.offset.top;\n          }\n        }\n\n        var tooltipPosition = {\n          \"left\": Math.min(self.$map.width() - self.$tooltip.outerWidth() - 5, mouseX - self.$map.offset().left + offsetLeft),\n          \"top\": Math.min(self.$map.height() - self.$tooltip.outerHeight() - 5, mouseY - self.$map.offset().top + offsetTop)\n        };\n\n        if (typeof elem.options.tooltip.overflow === \"object\") {\n          if (elem.options.tooltip.overflow.right === true) {\n            tooltipPosition.left = mouseX - self.$map.offset().left + 10;\n          }\n\n          if (elem.options.tooltip.overflow.bottom === true) {\n            tooltipPosition.top = mouseY - self.$map.offset().top + 20;\n          }\n        }\n\n        self.$tooltip.css(tooltipPosition);\n      }\n    },\n\n    /*\n     * Set the behaviour when mouse leaves element (\"mouseout\" event)\n     * It may be an area, a plot, a link or a legend element\n     * @param elem the map element\n     */\n    elemOut: function elemOut(elem) {\n      var self = this;\n      if (elem === undefined) return;\n      /* reset mapElem attributes */\n\n      if (elem.mapElem !== undefined) {\n        self.animate(elem.mapElem, elem.mapElem.originalAttrs, elem.mapElem.attrsHover.animDuration);\n      }\n      /* reset textElem attributes */\n\n\n      if (elem.textElem !== undefined) {\n        self.animate(elem.textElem, elem.textElem.originalAttrs, elem.textElem.attrsHover.animDuration);\n      }\n      /* reset tooltip */\n\n\n      if (elem.options && elem.options.tooltip !== undefined) {\n        self.$tooltip.css({\n          'display': 'none',\n          'top': -1000,\n          'left': -1000\n        });\n      } // workaround for older version of Raphael\n\n\n      if (elem.mapElem !== undefined || elem.textElem !== undefined) {\n        if (self.paper.safari) self.paper.safari();\n      }\n    },\n\n    /*\n     * Set the behaviour when mouse clicks element (\"click\" event)\n     * It may be an area, a plot or a link (but not a legend element which has its own function)\n     * @param elem the map element\n     */\n    elemClick: function elemClick(elem) {\n      var self = this;\n      if (elem === undefined) return;\n      /* Handle click when href defined */\n\n      if (!self.panning && elem.options.href !== undefined) {\n        window.open(elem.options.href, elem.options.target);\n      }\n    },\n\n    /*\n     * Get element options by merging default options, element options and legend options\n     * @param defaultOptions\n     * @param elemOptions\n     * @param legendOptions\n     */\n    getElemOptions: function getElemOptions(defaultOptions, elemOptions, legendOptions) {\n      var self = this;\n      var options = $.extend(true, {}, defaultOptions, elemOptions);\n\n      if (options.value !== undefined) {\n        if ($.isArray(legendOptions)) {\n          for (var i = 0; i < legendOptions.length; ++i) {\n            options = $.extend(true, {}, options, self.getLegendSlice(options.value[i], legendOptions[i]));\n          }\n        } else {\n          options = $.extend(true, {}, options, self.getLegendSlice(options.value, legendOptions));\n        }\n      }\n\n      return options;\n    },\n\n    /*\n     * Get the coordinates of the text relative to a bbox and a position\n     * @param bbox the boundary box of the element\n     * @param textPosition the wanted text position (inner, right, left, top or bottom)\n     * @param margin number or object {x: val, y:val} margin between the bbox and the text\n     */\n    getTextPosition: function getTextPosition(bbox, textPosition, margin) {\n      var textX = 0;\n      var textY = 0;\n      var textAnchor = \"\";\n\n      if (typeof margin === \"number\") {\n        if (textPosition === \"bottom\" || textPosition === \"top\") {\n          margin = {\n            x: 0,\n            y: margin\n          };\n        } else if (textPosition === \"right\" || textPosition === \"left\") {\n          margin = {\n            x: margin,\n            y: 0\n          };\n        } else {\n          margin = {\n            x: 0,\n            y: 0\n          };\n        }\n      }\n\n      switch (textPosition) {\n        case \"bottom\":\n          textX = (bbox.x + bbox.x2) / 2 + margin.x;\n          textY = bbox.y2 + margin.y;\n          textAnchor = \"middle\";\n          break;\n\n        case \"top\":\n          textX = (bbox.x + bbox.x2) / 2 + margin.x;\n          textY = bbox.y - margin.y;\n          textAnchor = \"middle\";\n          break;\n\n        case \"left\":\n          textX = bbox.x - margin.x;\n          textY = (bbox.y + bbox.y2) / 2 + margin.y;\n          textAnchor = \"end\";\n          break;\n\n        case \"right\":\n          textX = bbox.x2 + margin.x;\n          textY = (bbox.y + bbox.y2) / 2 + margin.y;\n          textAnchor = \"start\";\n          break;\n\n        default:\n          // \"inner\" position\n          textX = (bbox.x + bbox.x2) / 2 + margin.x;\n          textY = (bbox.y + bbox.y2) / 2 + margin.y;\n          textAnchor = \"middle\";\n      }\n\n      return {\n        \"x\": textX,\n        \"y\": textY,\n        \"textAnchor\": textAnchor\n      };\n    },\n\n    /*\n     * Get the legend conf matching with the value\n     * @param value the value to match with a slice in the legend\n     * @param legend the legend params object\n     * @return the legend slice matching with the value\n     */\n    getLegendSlice: function getLegendSlice(value, legend) {\n      for (var i = 0; i < legend.slices.length; ++i) {\n        if (legend.slices[i].sliceValue !== undefined && value === legend.slices[i].sliceValue || legend.slices[i].sliceValue === undefined && (legend.slices[i].min === undefined || value >= legend.slices[i].min) && (legend.slices[i].max === undefined || value <= legend.slices[i].max)) {\n          return legend.slices[i];\n        }\n      }\n\n      return {};\n    },\n\n    /*\n     * Animated view box changes\n     * As from http://code.voidblossom.com/animating-viewbox-easing-formulas/,\n     * (from https://github.com/theshaun works on mapael)\n     * @param x coordinate of the point to focus on\n     * @param y coordinate of the point to focus on\n     * @param w map defined width\n     * @param h map defined height\n     * @param duration defined length of time for animation\n     * @param easingFunction defined Raphael supported easing_formula to use\n     */\n    animateViewBox: function animateViewBox(targetX, targetY, targetW, targetH, duration, easingFunction) {\n      var self = this;\n      var cx = self.currentViewBox.x;\n      var dx = targetX - cx;\n      var cy = self.currentViewBox.y;\n      var dy = targetY - cy;\n      var cw = self.currentViewBox.w;\n      var dw = targetW - cw;\n      var ch = self.currentViewBox.h;\n      var dh = targetH - ch; // Init current ViewBox target if undefined\n\n      if (!self.zoomAnimCVBTarget) {\n        self.zoomAnimCVBTarget = {\n          x: targetX,\n          y: targetY,\n          w: targetW,\n          h: targetH\n        };\n      } // Determine zoom direction by comparig current vs. target width\n\n\n      var zoomDir = cw > targetW ? 'in' : 'out';\n      var easingFormula = Raphael.easing_formulas[easingFunction || \"linear\"]; // To avoid another frame when elapsed time approach end (2%)\n\n      var durationWithMargin = duration - duration * 2 / 100; // Save current zoomAnimStartTime before assigning a new one\n\n      var oldZoomAnimStartTime = self.zoomAnimStartTime;\n      self.zoomAnimStartTime = new Date().getTime();\n      /* Actual function to animate the ViewBox\n       * Uses requestAnimationFrame to schedule itself again until animation is over\n       */\n\n      var computeNextStep = function computeNextStep() {\n        // Cancel any remaining animationFrame\n        // It means this new step will take precedence over the old one scheduled\n        // This is the case when the user is triggering the zoom fast (e.g. with a big mousewheel run)\n        // This actually does nothing when performing a single zoom action\n        self.cancelAnimationFrame(self.zoomAnimID); // Compute elapsed time\n\n        var elapsed = new Date().getTime() - self.zoomAnimStartTime; // Check if animation should finish\n\n        if (elapsed < durationWithMargin) {\n          // Hold the future ViewBox values\n          var x, y, w, h; // There are two ways to compute the next ViewBox size\n          //  1. If the target ViewBox has changed between steps (=> ADAPTATION step)\n          //  2. Or if the target ViewBox is the same (=> NORMAL step)\n          //\n          // A change of ViewBox target between steps means the user is triggering\n          // the zoom fast (like a big scroll with its mousewheel)\n          //\n          // The new animation step with the new target will always take precedence over the\n          // last one and start from 0 (we overwrite zoomAnimStartTime and cancel the scheduled frame)\n          //\n          // So if we don't detect the change of target and adapt our computation,\n          // the user will see a delay at beginning the ratio will stays at 0 for some frames\n          //\n          // Hence when detecting the change of target, we animate from the previous target.\n          //\n          // The next step will then take the lead and continue from there, achieving a nicer\n          // experience for user.\n          // Change of target IF: an old animation start value exists AND the target has actually changed\n\n          if (oldZoomAnimStartTime && self.zoomAnimCVBTarget && self.zoomAnimCVBTarget.w !== targetW) {\n            // Compute the real time elapsed with the last step\n            var realElapsed = new Date().getTime() - oldZoomAnimStartTime; // Compute then the actual ratio we're at\n\n            var realRatio = easingFormula(realElapsed / duration); // Compute new ViewBox values\n            // The difference with the normal function is regarding the delta  value used\n            // We don't take the current (dx, dy, dw, dh) values yet because they are related to the new target\n            // But we take the old target\n\n            x = cx + (self.zoomAnimCVBTarget.x - cx) * realRatio;\n            y = cy + (self.zoomAnimCVBTarget.y - cy) * realRatio;\n            w = cw + (self.zoomAnimCVBTarget.w - cw) * realRatio;\n            h = ch + (self.zoomAnimCVBTarget.h - ch) * realRatio; // Update cw, cy, cw and ch so the next step take animation from here\n\n            cx = x;\n            dx = targetX - cx;\n            cy = y;\n            dy = targetY - cy;\n            cw = w;\n            dw = targetW - cw;\n            ch = h;\n            dh = targetH - ch; // Update the current ViewBox target\n\n            self.zoomAnimCVBTarget = {\n              x: targetX,\n              y: targetY,\n              w: targetW,\n              h: targetH\n            };\n          } else {\n            // This is the classical approach when nothing come interrupting the zoom\n            // Compute ratio according to elasped time and easing formula\n            var ratio = easingFormula(elapsed / duration); // From the current value, we add a delta with a ratio that will leads us to the target\n\n            x = cx + dx * ratio;\n            y = cy + dy * ratio;\n            w = cw + dw * ratio;\n            h = ch + dh * ratio;\n          } // Some checks before applying the new viewBox\n\n\n          if (zoomDir === 'in' && (w > self.currentViewBox.w || w < targetW)) {// Zooming IN and the new ViewBox seems larger than the current value, or smaller than target value\n            // We do NOT set the ViewBox with this value\n            // Otherwise, the user would see the camera going back and forth\n          } else if (zoomDir === 'out' && (w < self.currentViewBox.w || w > targetW)) {// Zooming OUT and the new ViewBox seems smaller than the current value, or larger than target value\n            // We do NOT set the ViewBox with this value\n            // Otherwise, the user would see the camera going back and forth\n          } else {\n            // New values look good, applying\n            self.setViewBox(x, y, w, h);\n          } // Schedule the next step\n\n\n          self.zoomAnimID = self.requestAnimationFrame(computeNextStep);\n        } else {\n          /* Zoom animation done ! */\n          // Perform some cleaning\n          self.zoomAnimStartTime = null;\n          self.zoomAnimCVBTarget = null; // Make sure the ViewBox hits the target!\n\n          if (self.currentViewBox.w !== targetW) {\n            self.setViewBox(targetX, targetY, targetW, targetH);\n          } // Finally trigger afterZoom event\n\n\n          self.$map.trigger(\"afterZoom\", {\n            x1: targetX,\n            y1: targetY,\n            x2: targetX + targetW,\n            y2: targetY + targetH\n          });\n        }\n      }; // Invoke the first step directly\n\n\n      computeNextStep();\n    },\n\n    /*\n     * requestAnimationFrame/cancelAnimationFrame polyfill\n     * Based on https://gist.github.com/jlmakes/47eba84c54bc306186ac1ab2ffd336d4\n     * and also https://gist.github.com/paulirish/1579671\n     *\n     * _requestAnimationFrameFn and _cancelAnimationFrameFn hold the current functions\n     * But requestAnimationFrame and cancelAnimationFrame shall be called since\n     * in order to be in window context\n     */\n    // The function to use for requestAnimationFrame\n    requestAnimationFrame: function requestAnimationFrame(callback) {\n      return this._requestAnimationFrameFn.call(window, callback);\n    },\n    // The function to use for cancelAnimationFrame\n    cancelAnimationFrame: function cancelAnimationFrame(id) {\n      this._cancelAnimationFrameFn.call(window, id);\n    },\n    // The requestAnimationFrame polyfill'd function\n    // Value set by self-invoking function, will be run only once\n    _requestAnimationFrameFn: function () {\n      var polyfill = function () {\n        var clock = new Date().getTime();\n        return function (callback) {\n          var currentTime = new Date().getTime(); // requestAnimationFrame strive to run @60FPS\n          // (e.g. every 16 ms)\n\n          if (currentTime - clock > 16) {\n            clock = currentTime;\n            callback(currentTime);\n          } else {\n            // Ask browser to schedule next callback when possible\n            return setTimeout(function () {\n              polyfill(callback);\n            }, 0);\n          }\n        };\n      }();\n\n      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || polyfill;\n    }(),\n    // The CancelAnimationFrame polyfill'd function\n    // Value set by self-invoking function, will be run only once\n    _cancelAnimationFrameFn: function () {\n      return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || clearTimeout;\n    }(),\n\n    /*\n     * SetViewBox wrapper\n     * Apply new viewbox values and keep track of them\n     *\n     * This avoid using the internal variable paper._viewBox which\n     * may not be present in future version of Raphael\n     */\n    setViewBox: function setViewBox(x, y, w, h) {\n      var self = this; // Update current value\n\n      self.currentViewBox.x = x;\n      self.currentViewBox.y = y;\n      self.currentViewBox.w = w;\n      self.currentViewBox.h = h; // Perform set view box\n\n      self.paper.setViewBox(x, y, w, h, false);\n    },\n\n    /*\n     * Animate wrapper for Raphael element\n     *\n     * Perform an animation and ensure the non-animated attr are set.\n     * This is needed for specific attributes like cursor who will not\n     * be animated, and thus not set.\n     *\n     * If duration is set to 0 (or not set), no animation are performed\n     * and attributes are directly set (and the callback directly called)\n     */\n    // List extracted from Raphael internal vars\n    // Diff between Raphael.availableAttrs  and  Raphael._availableAnimAttrs\n    _nonAnimatedAttrs: [\"arrow-end\", \"arrow-start\", \"gradient\", \"class\", \"cursor\", \"text-anchor\", \"font\", \"font-family\", \"font-style\", \"font-weight\", \"letter-spacing\", \"src\", \"href\", \"target\", \"title\", \"stroke-dasharray\", \"stroke-linecap\", \"stroke-linejoin\", \"stroke-miterlimit\"],\n\n    /*\n     * @param element Raphael element\n     * @param attrs Attributes object to animate\n     * @param duration Animation duration in ms\n     * @param callback Callback to eventually call after animation is done\n     */\n    animate: function animate(element, attrs, duration, callback) {\n      var self = this; // Check element\n\n      if (!element) return;\n\n      if (duration > 0) {\n        // Filter out non-animated attributes\n        // Note: we don't need to delete from original attribute (they won't be set anyway)\n        var attrsNonAnimated = {};\n\n        for (var i = 0; i < self._nonAnimatedAttrs.length; i++) {\n          var attrName = self._nonAnimatedAttrs[i];\n\n          if (attrs[attrName] !== undefined) {\n            attrsNonAnimated[attrName] = attrs[attrName];\n          }\n        } // Set non-animated attributes\n\n\n        element.attr(attrsNonAnimated); // Start animation for all attributes\n\n        element.animate(attrs, duration, 'linear', function () {\n          if (callback) callback();\n        });\n      } else {\n        // No animation: simply set all attributes...\n        element.attr(attrs); // ... and call the callback if needed\n\n        if (callback) callback();\n      }\n    },\n\n    /*\n     * Check for Raphael bug regarding drawing while beeing hidden (under display:none)\n     * See https://github.com/neveldo/jQuery-Mapael/issues/135\n     * @return true/false\n     *\n     * Wants to override this behavior? Use prototype overriding:\n     *     $.mapael.prototype.isRaphaelBBoxBugPresent = function() {return false;};\n     */\n    isRaphaelBBoxBugPresent: function isRaphaelBBoxBugPresent() {\n      var self = this; // Draw text, then get its boundaries\n\n      var textElem = self.paper.text(-50, -50, \"TEST\");\n      var textElemBBox = textElem.getBBox(); // remove element\n\n      textElem.remove(); // If it has no height and width, then the paper is hidden\n\n      return textElemBBox.width === 0 && textElemBBox.height === 0;\n    },\n    // Default map options\n    defaultOptions: {\n      map: {\n        cssClass: \"map\",\n        tooltip: {\n          cssClass: \"mapTooltip\"\n        },\n        defaultArea: {\n          attrs: {\n            fill: \"#343434\",\n            stroke: \"#5d5d5d\",\n            \"stroke-width\": 1,\n            \"stroke-linejoin\": \"round\"\n          },\n          attrsHover: {\n            fill: \"#f38a03\",\n            animDuration: 300\n          },\n          text: {\n            position: \"inner\",\n            margin: 10,\n            attrs: {\n              \"font-size\": 15,\n              fill: \"#c7c7c7\"\n            },\n            attrsHover: {\n              fill: \"#eaeaea\",\n              \"animDuration\": 300\n            }\n          },\n          target: \"_self\",\n          cssClass: \"area\"\n        },\n        defaultPlot: {\n          type: \"circle\",\n          size: 15,\n          attrs: {\n            fill: \"#0088db\",\n            stroke: \"#fff\",\n            \"stroke-width\": 0,\n            \"stroke-linejoin\": \"round\"\n          },\n          attrsHover: {\n            \"stroke-width\": 3,\n            animDuration: 300\n          },\n          text: {\n            position: \"right\",\n            margin: 10,\n            attrs: {\n              \"font-size\": 15,\n              fill: \"#c7c7c7\"\n            },\n            attrsHover: {\n              fill: \"#eaeaea\",\n              animDuration: 300\n            }\n          },\n          target: \"_self\",\n          cssClass: \"plot\"\n        },\n        defaultLink: {\n          factor: 0.5,\n          attrs: {\n            stroke: \"#0088db\",\n            \"stroke-width\": 2\n          },\n          attrsHover: {\n            animDuration: 300\n          },\n          text: {\n            position: \"inner\",\n            margin: 10,\n            attrs: {\n              \"font-size\": 15,\n              fill: \"#c7c7c7\"\n            },\n            attrsHover: {\n              fill: \"#eaeaea\",\n              animDuration: 300\n            }\n          },\n          target: \"_self\",\n          cssClass: \"link\"\n        },\n        zoom: {\n          enabled: false,\n          minLevel: 0,\n          maxLevel: 10,\n          step: 0.25,\n          mousewheel: true,\n          touch: true,\n          animDuration: 200,\n          animEasing: \"linear\",\n          buttons: {\n            \"reset\": {\n              cssClass: \"zoomButton zoomReset\",\n              content: \"&#8226;\",\n              // bullet sign\n              title: \"Reset zoom\"\n            },\n            \"in\": {\n              cssClass: \"zoomButton zoomIn\",\n              content: \"+\",\n              title: \"Zoom in\"\n            },\n            \"out\": {\n              cssClass: \"zoomButton zoomOut\",\n              content: \"&#8722;\",\n              // minus sign\n              title: \"Zoom out\"\n            }\n          }\n        }\n      },\n      legend: {\n        redrawOnResize: true,\n        area: [],\n        plot: []\n      },\n      areas: {},\n      plots: {},\n      links: {}\n    },\n    // Default legends option\n    legendDefaultOptions: {\n      area: {\n        cssClass: \"areaLegend\",\n        display: true,\n        marginLeft: 10,\n        marginLeftTitle: 5,\n        marginBottomTitle: 10,\n        marginLeftLabel: 10,\n        marginBottom: 10,\n        titleAttrs: {\n          \"font-size\": 16,\n          fill: \"#343434\",\n          \"text-anchor\": \"start\"\n        },\n        labelAttrs: {\n          \"font-size\": 12,\n          fill: \"#343434\",\n          \"text-anchor\": \"start\"\n        },\n        labelAttrsHover: {\n          fill: \"#787878\",\n          animDuration: 300\n        },\n        hideElemsOnClick: {\n          enabled: true,\n          opacity: 0.2,\n          animDuration: 300\n        },\n        slices: [],\n        mode: \"vertical\"\n      },\n      plot: {\n        cssClass: \"plotLegend\",\n        display: true,\n        marginLeft: 10,\n        marginLeftTitle: 5,\n        marginBottomTitle: 10,\n        marginLeftLabel: 10,\n        marginBottom: 10,\n        titleAttrs: {\n          \"font-size\": 16,\n          fill: \"#343434\",\n          \"text-anchor\": \"start\"\n        },\n        labelAttrs: {\n          \"font-size\": 12,\n          fill: \"#343434\",\n          \"text-anchor\": \"start\"\n        },\n        labelAttrsHover: {\n          fill: \"#787878\",\n          animDuration: 300\n        },\n        hideElemsOnClick: {\n          enabled: true,\n          opacity: 0.2,\n          animDuration: 300\n        },\n        slices: [],\n        mode: \"vertical\"\n      }\n    }\n  }; // Mapael version number\n  // Accessible as $.mapael.version\n\n  Mapael.version = version; // Extend jQuery with Mapael\n\n  if ($[pluginName] === undefined) $[pluginName] = Mapael; // Add jQuery DOM function\n\n  $.fn[pluginName] = function (options) {\n    // Call Mapael on each element\n    return this.each(function () {\n      // Avoid leaking problem on multiple instanciation by removing an old mapael object on a container\n      if ($.data(this, pluginName)) {\n        $.data(this, pluginName).destroy();\n      } // Create Mapael and save it as jQuery data\n      // This allow external access to Mapael using $(\".mapcontainer\").data(\"mapael\")\n\n\n      $.data(this, pluginName, new Mapael(this, options));\n    });\n  };\n\n  return Mapael;\n});","map":null,"metadata":{},"sourceType":"script"}